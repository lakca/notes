---
title: Swift
date: 2020-09-08T08:54:35.929Z
---

# è¯­è¨€

> å®‰å…¨ã€å¿«é€Ÿã€äº¤äº’å¼ï¼ˆæä¾›è§£é‡Šå™¨ï¼‰ã€å¯Œæœ‰è¡¨ç°åŠ›çš„å…·æœ‰å·¥ä¸šå“è´¨çš„ç¼–ç¨‹è¯­è¨€ã€‚

## ç‰¹æ€§

- ä¸ç›´æ¥æš´éœ²æŒ‡é’ˆ/å†…å­˜ï¼Œä½†æä¾›äº†æ ‡å‡†åº“è¿›è¡Œæ”¯æŒ
- æ•°æ®ä¼ é€’ç­–ç•¥æ˜¯å¼•ç”¨è¿˜æ˜¯å¤åˆ¶åœ¨ç±»å‹å®ç°ï¼ˆå€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹ï¼‰æ—¶å·²ç»å†³å®š
- è‡ªåŠ¨ç®¡ç†å†…å­˜ï¼Œé€šè¿‡ä¸¥æ ¼çš„å¼•ç”¨è®¡æ•°ï¼ˆ*Deterministic Reference Counting*ï¼‰è‡ªåŠ¨è¿›è¡Œå†…å­˜å›æ”¶ï¼Œæ²¡æœ‰åƒåœ¾å›æ”¶å¯¹è¿›ç¨‹çš„å¹²é¢„
- å®Œå…¨çš„Unicodeç¼–ç 
- å¼ºç±»å‹ï¼ˆç¼–è¯‘æ—¶ç¡®å®šç±»å‹ï¼‰
- é™æ€ç±»å‹ï¼ˆä¸å¯åœ¨~~ä½¿ç”¨ä¸­æ”¹å˜å˜é‡ç±»å‹~~ï¼‰
- æ”¯æŒç±»å‹æ¨æ–­ï¼ˆ*Type Inference*ï¼‰
- ï¼ˆå˜é‡æˆ–å¸¸é‡ï¼‰è°ƒç”¨å‰åˆå§‹åŒ–å³å¯ï¼ˆ*Initialization Before Used*ï¼‰
- æ•´å‹æº¢å‡ºæ£€æµ‹ï¼ˆ*Integer Bounds*ï¼‰
- æ˜¾å¼å¤„ç†ç©ºå€¼ï¼ˆ*Optional*ï¼‰
- ç¦æ­¢å˜é‡é®è”½ï¼ˆ*~~Shadowing~~*ï¼‰
- ç¦æ­¢è¶Šç•Œç´¢å¼•ï¼ˆ*Out-of-Bounds Errors*ï¼‰
- æ”¯æŒå…ƒç»„ï¼ˆ*Tuple*ï¼‰ã€å¤šå€¼è¿”å›ï¼ˆ*Multiple Return Values*ï¼‰
- æ”¯æŒ[æ³›å‹](#æ³›å‹generics)ï¼ˆ*Generics*ï¼‰
- æ”¯æŒ[åè®®](#åè®®protocol)ï¼ˆ*Protocols*ï¼‰
- æ”¯æŒç±»å‹[æ‰©å±•](#æ‰©å±•extension)ï¼ŒåŒ…æ‹¬åŸºæœ¬ç±»å‹ï¼ˆ*Extensions*ï¼‰
- æ”¯æŒé‡è½½ï¼ŒåŒ…æ‹¬æ–¹æ³•ã€è¿ç®—ç¬¦å’Œä¸‹æ ‡ç­‰ç­‰ï¼ˆ*Overloading*ï¼‰
- æ”¯æŒå­—ç¬¦ä¸²æ’å€¼ï¼ˆ*String Interpolation*ï¼‰
- æ”¯æŒ[é—­åŒ…](#é—­åŒ…closures)ï¼ˆ*Closure*ï¼‰
- æ”¯æŒå®å‚æ ‡ç­¾ï¼ˆå½¢å‚å’Œå®å‚å¯ä»¥ä¸åŒåç§°ï¼‰
- æ”¯æŒä¸å®šå‚æ•°
- æ”¯æŒ[ä¿®æ”¹å‡½æ•°å‚æ•°](#å¯ä¿®æ”¹å‚æ•°-inout)
- æ”¯æŒæšä¸¾è·è½½ï¼ˆ*Enumeration Playload*ï¼‰
- æ”¯æŒæ¨¡å¼åŒ¹é…ï¼ˆ*Pattern Matching*ï¼‰
- æ”¯æŒé”™è¯¯æ•è·ã€å†’æ³¡å’Œæ–­è¨€
- å¸¸é‡æ²¡æœ‰ä¸¥æ ¼çš„å€¼ä¸å¯å˜ï¼Œå¯¹äºå¼•ç”¨ç±»å‹åªå­˜å‚¨å¼•ç”¨åœ°å€ï¼Œå±æ€§ä»ç„¶æ˜¯å¯å˜çš„ï¼ˆç±»ä¼¼*Javascript*çš„å¸¸é‡å¯¹è±¡ï¼‰
- å¥å°¾åˆ†å·å¯é€‰`;`ï¼ˆåŒ*Javascript*ï¼Œæ¢è¡Œç¬¦å’Œåˆ†å·å‡ä¸ºè¯­å¥åˆ†éš”ç¬¦ï¼‰
- ç­‰å·ï¼ˆ`=`ï¼‰ä¸¤ä¾§å¿…é¡»åŒæ—¶æœ‰æˆ–æ²¡æœ‰ç©ºæ ¼

## çº¦å®š

- æ ‡è¯†ç¬¦ä½¿ç”¨*camelCase*ï¼ˆå˜é‡ã€å‡½æ•°ç­‰ï¼‰å’Œ*PascalCase*ï¼ˆç±»ã€ç»“æ„ã€æšä¸¾ç­‰ï¼‰å‘½åæ–¹å¼

## é‡è¦æ¦‚å¿µ

- ç»“æ„ï¼ˆ*Structure*ï¼‰
- ç±»ï¼ˆ*Class*ï¼‰
- æ‰©å±•ï¼ˆ*Extension*ï¼‰
- åè®®ï¼ˆ*Protocol*ï¼‰
- è¡Œä¸ºä½“ï¼ˆ*Actor*ï¼‰

## æ–‡æ¡£

- [Getting Started](https://www.swift.org/getting-started/)
- [A Swift Tour][guidedtour]
- [Swift Programming Language](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/)
- [Swift Language Reference][aboutthelanguagereference]
- [Swift Standard Library](https://developer.apple.com/documentation/swift/swift-standard-library)
- [API Design Guidelines](https://www.swift.org/documentation/api-design-guidelines/)

## å·¥å…·

- [Swift-DocC](https://www.swift.org/documentation/docc)ï¼šä¸ºä½ çš„Swifté¡¹ç›®ç”Ÿæˆæ–‡æ¡£

# å˜é‡å’Œå¸¸é‡

- å£°æ˜æ—¶é¡»ç¡®å®šç±»å‹ï¼›
- ä½¿ç”¨å‰å¿…é¡»å£°æ˜ï¼›
- ä½¿ç”¨å‰åˆå§‹åŒ–å³å¯ï¼›
- ä¸æ”¯æŒåç§°é®è”½ï¼ˆäºŒæ¬¡å£°æ˜ï¼‰ï¼›
- å‘½åå¯ä»¥ä½¿ç”¨è¯­è¨€å…³é”®å­—ï¼Œéœ€åå¼•å·ï¼ˆ<code>``</code>ï¼‰åŒ…è£¹ï¼Œä½†ä¸å»ºè®®ï¼›
- å‘½åæ”¯æŒ*Unicode*å­—ç¬¦ï¼Œä½†ä¸æ”¯æŒç©ºç™½å­—ç¬¦ã€æ•°å­¦ç¬¦å·ã€ç®­å¤´ã€[çº¿æ¡†å­—ç¬¦](https://en.wikipedia.org/wiki/Box-drawing_character)ã€[ç§åŸŸå­—ç¬¦](https://en.wikipedia.org/wiki/Private_Use_Areas)ç­‰å­—ç¬¦ã€‚ï¼ˆ*Constant and variable names canâ€™t contain whitespace characters, mathematical symbols, arrows, private-use Unicode scalar values, or line- and box-drawing characters. Nor can they begin with a number, although numbers may be included elsewhere within the name.*ï¼‰
- å¸¸é‡å¯åœ¨å…¨å±€æˆ–å±€éƒ¨å£°æ˜ï¼›
- å¸¸é‡ä¸å½±å“ç»“æ„ç­‰å¤åˆç±»å‹ï¼ˆ*Compound Types*ï¼‰å†…éƒ¨å±æ€§çš„å¯å˜æ€§ï¼›

```swift
// å£°æ˜æ—¶é¡»ç¡®å®šç±»å‹ï¼š
var a: Int = 1
let A: Int = 1;

// åˆå§‹åŒ–åªè¦æ±‚åœ¨ä½¿ç”¨å‰å³å¯ï¼š
var b: Int
var B: Int
b = 1
B = 1

// ä½†åˆå§‹åŒ–å¯è‡ªåŠ¨æ¨æ–­ç±»å‹ï¼š
var c = 1
let C = 1

// å¯ä»¥åœ¨åŒä¸€è¡Œå£°æ˜å¤šä¸ªå˜é‡ï¼š
var d = 2, e = 3
var f, g: Int
let d = 2, e = 3
let f, g: Int
```

# ç±»å‹ï¼ˆTypesï¼‰

è·å–æ•°æ®ç±»å‹ï¼š

```swift
print(type(of: "hello"))
```

## ç±»å‹åˆ«åï¼ˆType Aliasï¼‰

```swift
typealias Audio = Int8
```

## å€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹ï¼ˆValue Types & Reference Typesï¼‰

> [å€¼ç±»å‹ï¼ˆValue Typesï¼‰][Structures-and-Enumerations-Are-Value-Types]åœ¨å…¶è¢«ä¼ é€’æ—¶ï¼ˆå¦‚èµ‹å€¼ç»™å˜é‡ã€å¸¸é‡æˆ–è€…ä½œä¸ºå‚æ•°ä¼ å…¥å‡½æ•°ç­‰ï¼‰ä¼šå¤åˆ¶æ•°æ®ã€‚åŒ…æ‹¬[ç»“æ„ï¼ˆStructuresï¼‰å’Œæšä¸¾ï¼ˆEnumerationsï¼‰][Structures-and-Enumerations-Are-Value-Types]

> ä¸å€¼ç±»å‹ç›¸å¯¹ï¼Œ[å¼•ç”¨ç±»å‹ï¼ˆReference Typesï¼‰][Classes-Are-Reference-Types]åœ¨å…¶è¢«ä¼ é€’æ—¶åªä¼šåˆ›å»ºå¼•ç”¨ï¼Œè€Œä¸ä¼šå¤åˆ¶æ•°æ®ï¼Œå‰åå‡æŒ‡å‘åŒä¸€ä¸ªå®ä¾‹ã€‚åŒ…æ‹¬[ç±»ï¼ˆClassesï¼‰][Classes-Are-Reference-Types]å’Œ[è¡Œä¸ºä½“ï¼ˆActorsï¼‰](#è¡Œä¸ºä½“actor)ã€‚

**åŸºç¡€ç±»å‹ï¼ˆBasic Typesï¼‰åœ¨åº•å±‚éƒ½æ˜¯é€šè¿‡ç»“æ„ï¼ˆStructuresï¼‰æ¥å®ç°çš„ï¼Œæ•…å‡æ˜¯å€¼ç±»å‹ï¼ˆValue Typesï¼‰**ã€‚åŒ…æ‹¬æ•°å­—ï¼ˆ`Int`, `Double`ï¼‰ã€å¸ƒå°”å€¼ï¼ˆ`Bool`ï¼‰ã€å­—ç¬¦ä¸²ï¼ˆ`String`ï¼‰ã€æ•°ç»„ï¼ˆ`Array`ï¼‰ã€é›†åˆï¼ˆ`Set`ï¼‰ã€å­—å…¸ï¼ˆ`Dictionary`ï¼‰ç­‰ã€‚(*In fact, all of the basic types in Swiftâ€”integers, floating-point numbers, Booleans, strings, arrays and dictionariesâ€”are value types, and are implemented as structures behind the scenes.*)

*ä¸ºäº†ä¼˜åŒ–æ€§èƒ½ï¼Œåœ¨æ ‡å‡†åº“ä¸­å®šä¹‰çš„é›†åˆç±»å‹ï¼ˆå¦‚æ•°ç»„ã€å­—å…¸å’Œå­—ç¬¦ä¸²ç­‰ï¼‰åœ¨ä¼ é€’æ—¶ä¸ä¼šç«‹å³å¤åˆ¶ï¼Œåªæœ‰åœ¨æ•°æ®è¢«ä¿®æ”¹å‰æ‰ä¼šè¢«å¤åˆ¶ã€‚*

## åŸºæœ¬ç±»å‹ï¼ˆBasic Typesï¼‰

- å…·æœ‰æ¨æ–­ç±»å‹

```swift
let foo: String = "hello"
// ç­‰ä»·äº
let foo = "hello"
```

### å­—ç¬¦ä¸²ï¼ˆStringï¼‰å’Œå­—ç¬¦ï¼ˆCharacterï¼‰

```swift
let str: String = "hello"
let char: Character = "h"
```

```swift
let str = "hello"
```

ä½¿ç”¨Unicodeç å­—ç¬¦ï¼š

```swift
print("\u{1F425}") // ğŸ¥
```

å­—ç¬¦ä¸²å’Œå­—ç¬¦æ··åˆè¿ç®—ï¼š

```swift
let char: Character = "!"
let chars: [Character] = ["C", "a", "t", "!", "ğŸ±"]
var str = String(chars)
str.append(char)
```

#### å­å­—ç¬¦ä¸²ï¼ˆSubstringï¼‰

> [å­å­—ç¬¦ä¸²ï¼ˆSubstringï¼‰](https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID555)æ˜¯å¼•ç”¨åŸå­—ç¬¦ä¸²ï¼ˆStringï¼‰å†…å­˜åœ°å€ä¸€éƒ¨åˆ†ï¼Œè‹¥éœ€è¦ç‹¬ç«‹å­˜æ´»éœ€æ‰‹åŠ¨å¤åˆ¶æˆå­—ç¬¦ä¸²ã€‚é€šè¿‡ä¸‹æ ‡ã€åˆ‡ç‰‡æˆ–æŸäº›æ–¹æ³•è¿”å›ï¼ˆå¦‚`prefix(_:)`ï¼‰å¾—åˆ°çš„å­—ç¬¦ä¸²å‡ä¸ºå­å­—ç¬¦ä¸²ï¼Œç±»å‹ä¸º`Substring`ã€‚

#### å­—ç¬¦ä¸²å­—é¢é‡

å­—ç¬¦ä¸²å’Œå­—ç¬¦å‡ç”¨åŒå¼•å·ï¼ˆ`"`ï¼‰æ ‡æ³¨ï¼š

```swift
let a = "hello"
let b = String("hello")
```
```swift
let a = "h"
let b = Character("i")
```

å¤šè¡Œå­—ç¬¦ä¸²ç”¨ä¸‰ä¸ªåŒå¼•å·ï¼ˆ`"""`ï¼‰æ ‡æ³¨ï¼Œä¸”å¼•å·å¿…é¡»åœ¨å•ç‹¬ä¸€è¡Œï¼š

```swift
let multiline = """
1. must begin/end with a newline.
2. end with backslash \
   to skip line break
"""
```

å¤šè¡Œå­—ç¬¦ä¸²é¦–è¡Œå‰çš„ç©ºæ ¼å¿½ç•¥ï¼Œåç»­è¡Œå‰åŒæ•°é‡çš„ç©ºæ ¼ä¹Ÿè¢«å¿½ç•¥ï¼Œä»¥ä¸‹ä¸ä¸ŠåŒï¼š

```swift
let multiline = """
   1. must begin/end with a newline.
   2. end with backslash \
      to skip line break
"""
```

ä¸ºäº†ç®€åŒ–è½¬ä¹‰ï¼Œå¤šè¡Œå­—ç¬¦ä¸²è¿˜å¯ä»¥è‡ªå®šä¹‰(v5.0) [æ‰©å±•å®šç•Œç¬¦](https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID606)ï¼ˆ*Extended String Delimiters*ï¼‰ï¼š

```swift
// ç”¨ # ä½œä¸ºå­—ç¬¦ä¸²çš„æ‰©å±•å®šç•Œç¬¦
print(#"hello\n world""#) // hello\n world"

// åŒè¡Œæ³¨é‡Šç¬¦å·ç”± \ å˜æˆ \#
print(#"""
hello \#
world\n"""
"""#) // hello world\n"""
```

#### å­—ç¬¦ä¸²æ’å€¼

> [æ’å€¼](https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID292)å†…å®¹ä½¿ç”¨å¸¦æœ‰è½¬ä¹‰çš„å°æ‹¬å· `\()`åŒ…è£¹ã€‚

```swift
print("6 times 7 is \(6 * 7).") // 6 times 7 is 42.

print(#"6 times 7 is \(6 * 7)."#) // 6 times 7 is \(6 * 7).

print(#"6 times 7 is \#(6 * 7)."#) // 6 times 7 is 42.
```

#### å­—ç¬¦ä¸²æ¯”è¾ƒ

ä½¿ç”¨åŒç­‰å·ï¼ˆ`==`ï¼‰åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æ‰©å±•å­—ç¬¦ç°‡æ˜¯å¦ç­‰ä»·ï¼Œæ¢å¥è¯è¯´ï¼Œä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åœ¨äººç±»è¯­è¨€ä¸Šå®Œå…¨ç›¸åŒï¼ˆ*same linguistic meaning and appearance*ï¼‰ï¼š

```swift
// Voulez-vous un cafÃ©?
let eAcuteQuestion = "Voulez-vous un caf\u{E9}?"
let combinedEAcuteQuestion = "Voulez-vous un caf\u{65}\u{301}?"
print(eAcuteQuestion == combinedEAcuteQuestion) // true

let latinCapitalLetterA: Character = "\u{41}" // æ‹‰ä¸å­—æ¯Aï¼Œå¦‚è‹±è¯­
let cyrillicCapitalLetterA: Character = "\u{0410}" // è¥¿é‡Œå°”å­—æ¯Ğï¼Œå¦‚ä¿„è¯­
print(latinCapitalLetterA == cyrillicCapitalLetterA) // false
```

#### å­—ç¬¦ä¸²æ–¹æ³•

```swift
var phrase = "abcde"

// åˆ¤æ–­ç©ºå­—ç¬¦ä¸²
print(phrase.isEmpty) // false
// å­—ç¬¦æ•°é‡
print(phrase.count) // 5
// è·å–ç´¢å¼•
print(phrase.firstIndex(of: "a")) // Optional(Swift.String.Index(_rawBits: 1))
// æ ¹æ®ç´¢å¼•è·å–å­—ç¬¦
print(phrase[phrase.startIndex]) // a
print(phrase[phrase.index(before: phrase.endIndex)]) // e
print(phrase[phrase.index(after: phrase.startIndex)]) // b
print(phrase[phrase.index(phrase.startIndex, offsetBy: 2)]) // c
print(phrase[phrase.index(phrase.endIndex, offsetBy: -2)]) // d
print(phrase[..<phrase.firstIndex(of: "c")!]) // ab
for i in phrase.indices { print(phrase[i], terminator: "") } // abcde

// ä¿®æ”¹
phrase += "fg"
phrase.append("h")
phrase.insert("i", at: phrase.endIndex) // abcdefghi
phrase.insert(contentsOf: "jk", at: phrase.endIndex) //abcdefghijk
print(phrase.remove(at: phrase.index(before: phrase.endIndex))) // k
phrase.removeSubrange(
	phrase.index(after: phrase.startIndex)..<phrase.endIndex) // a

// å‰ç¼€/åç¼€
assert("hello world".hasPrefix("hello"))
assert("hello world!".hasSuffix("!"))
```

#### Swiftå­—ç¬¦èŒƒå›´ï¼šæ‰©å±•å­—ç¬¦ç°‡ï¼ˆExtended Grapheme Clustersï¼‰

> æ‰©å±•å­—ç¬¦ç°‡ï¼ŒåŒ…æ‹¬å•ç å­—ç¬¦ï¼Œå’Œä½¿ç”¨å¤šä¸ªå•ç ç»„åˆäº§ç”Ÿçš„å¤æ‚å­—ç¬¦ã€‚å¦‚`e`çš„å˜ä½“`eÌ`å¯ä»¥æ˜¯`\u{e9}`ï¼Œæˆ–ç”±`e`å’Œ`\u{301}`ä¸¤ä¸ªå•ç ç»„åˆè€Œæˆã€‚(Extended Grapheme Cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.)ã€‚

> Swiftå­—ç¬¦çš„èŒƒå›´å³æ‰©å±•å­—ç¬¦ç°‡ã€‚(Every instance of Swiftâ€™s Character type represents a single extended grapheme cluster.)

```swift
print("\u{1F1E6} to \u{1F1FF}") //  REGIONAL INDICATOR SYMBOL ğŸ‡¦ to ğŸ‡¿
print("\u{1F1E8}\u{1F1F3}") // ğŸ‡¨ + ğŸ‡³ = ğŸ‡¨ğŸ‡³, regional indicator for China
print("e\u{304} e\u{301} e\u{306} e\u{300}") // eÌ„ eÌ eÌ† eÌ€
```

- Swiftâ€™s use of Extended Grapheme Clusters for Character values means that string concatenation and modification may not always affect a stringâ€™s character count.

- Extended Grapheme Clusters can be composed of multiple Unicode scalars. This means that different charactersâ€”and different representations of the same characterâ€”can require different amounts of memory to store.

```swift
var word = "cafe"
print("the number of characters in \(word) is \(word.count)")
// the number of characters in cafe is 4
word += "\u{301}"    // COMBINING ACUTE ACCENT, U+0301
print("the number of characters in \(word) is \(word.count)")
// the number of characters in cafeÌ is 4
```

### æ•°å­—ï¼ˆNumberï¼‰

> `Int`ï¼ˆ32bit/64bitï¼‰ã€`Int16`ã€`Int32`ã€`Int64`ï¼›`UInt`ï¼ˆ32bit/64bitï¼‰ã€`UInt16`ã€`UInt32`ã€`UInt64`ã€`Float`ï¼ˆ32bitï¼‰ã€`Double`ï¼ˆ64bitï¼‰

- ç¦æ­¢æº¢å‡ºï¼›
- æ”¯æŒå­—é¢é‡æ ¼å¼åŒ–ï¼›

```swift
// æ•´æ•°é»˜è®¤ç±»å‹ä¸º`Int`ï¼š
assert(type(of: 1) == Int.self)

// æµ®ç‚¹æ•°é»˜è®¤ç±»å‹ä¸º`Double`ï¼š
assert(type(of: 1.0) == Double.self)

// ç±»å‹è½¬æ¢ï¼š
assert(type(of: Int8(1.1)) == Int8.self)

// æ•°å­—å­—é¢é‡å…¼å®¹æ‰€æœ‰æ•°å­—ç±»å‹ï¼š
let c: Float = 1 // ä¸éœ€è¦å†™æˆ1.0

// å­—é¢é‡æ”¯æŒè¡¥`0`å’Œ`_`åˆ†éš”ç¬¦è¿›è¡Œæ ¼å¼åŒ–ï¼š
assert(1_000_000 == 1000000)
assert(00.1200 == 0.12)

// äºŒè¿›åˆ¶ï¼ˆ`0b`ï¼‰ã€å…«è¿›åˆ¶ï¼ˆ`0o`ï¼‰ã€åå…­è¿›åˆ¶ï¼ˆ`0x`ï¼‰ï¼š
print(31, 0b11111, 0o37, 0x1f)

// åè¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•ï¼š
assert(1.2e2 == 1.2e-2)

// åå…­è¿›åˆ¶ï¼ˆæµ®ç‚¹æ•°å¿…é¡»ä½¿ç”¨ï¼‰ç§‘å­¦è®¡æ•°æ³•ï¼ˆåå…­è¿›åˆ¶ç§‘å­¦è®¡æ•°æ³•ä»¥2ä¸ºåº•æ•°ï¼‰ï¼š
assert(0x1.2p2 == 4.5) // (1 + 2 * 16^-1) * 2^2
assert(0x1.2p-2 == 0.28125) // (1 + 2 * 16^-1) * 2^-2

// æœ€å¤§å€¼ã€æœ€å°å€¼ï¼š
assert(Int8.max == 127)
assert(Int8.min == -128)
```

### å¸ƒå°”ï¼ˆBooleanï¼‰

```swift
let orangesAreOrange: Bool = true
let turnipsAreDelicious = false
```

> Swiftæ˜¯ç±»å‹å®‰å…¨çš„ï¼Œä¸å…è®¸éå¸ƒå°”å€¼æ›¿ä»£ï¼ˆè‡ªåŠ¨è½¬æ¢æˆï¼‰å¸ƒå°”å€¼ã€‚

```swift
if 1 {} // error
```

### å…ƒç»„ï¼ˆTuplesï¼‰

åŒ¿åå…ƒç»„ï¼š

```swift
let http404Error = (404, "Not Found")
assert(http404Error.0 == 404)

let a = 1, b = 2
let c = (a, b)
assert(c == (1, 2))
```

å…·åå…ƒç»„ï¼š

```swift
let http200Status = (statusCode: 200, description: "OK")
```

è§£æ„å…ƒç»„ï¼š

```swift
let (statusCode, statusMessage) = http404Error
// è§£æ„æ— éœ€åŒå
let (code, msg) = http404Error
```

### é›†åˆç±»å‹ï¼ˆCollectionï¼‰

> [é›†åˆç±»å‹](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html)ï¼Œæ˜¯åŒä¸€ç±»å‹å€¼çš„é›†åˆã€‚

- å†…éƒ¨å…ƒç´ ä¸æ•°æ®ä¿æŒåŒæ ·çš„å¯å˜æ€§/ä¸å¯å˜æ€§

- ä¸å…è®¸ç´¢å¼•èŒƒå›´å¤–çš„è®¿é—®

- å­—é¢é‡æœ«å°¾å…ƒç´ åé¢çš„é€—å·`,`å¯é€‰

![CollectionTypes](https://docs.swift.org/swift-book/_images/CollectionTypes_intro_2x.png)

- `.count`
- `.startIndex`
- `.endIndex`
- `.indices`
- `.isEmpty`
- `.index()`

### æ•°ç»„ï¼ˆArrayï¼‰

> å€¼çš„æœ‰åºé›†åˆã€‚

```swift
Array<Value>
```

```swift
// æ— åˆå§‹åŒ–å£°æ˜
let arr: Array<Int>
let arr: [Int]

// å£°æ˜ç©ºæ•°ç»„
let arr = Array<Int>()
let arr = [Int]()
let arr: Array<Int> = []
let arr: [Int] = []

// åˆå§‹åŒ–å£°æ˜
let arr = [Int](repeating: 0, count: 3) // [0, 0, 0]
let arr = Array<Int>(repeating: 0, count: 3) // [0, 0, 0]
let arr = Array(repeating: 0, count: 3) // [0, 0, 0]

// æ¨æ–­å£°æ˜
let arr = [1, 2]
let arr = [1, 2] + [2, 3]
```

```swift
var arr = [Int]()

// æ·»åŠ å…ƒç´ 
arr += [1, 2]
arr.append(3)
arr.insert(0, at: 0) // [0, 1, 2, 3]

// æ›¿æ¢å…ƒç´ 
arr[1] = 2
arr[2...3] = [5] // [0, 2, 5]

// åˆ é™¤å…ƒç´ 
print(arr.remove(at: 1)) // 2
print(arr.removeLast()) // 5

// éå†
for e in arr {}
for (i, e) in arr.enumerated() {}
```

### é›†åˆï¼ˆSetï¼‰

> å”¯ä¸€å€¼çš„æ— åºé›†åˆã€‚

- é›†åˆå…ƒç´ å¿…é¡»æ˜¯å®ç°äº†å¯æ•£åˆ—åè®®ï¼ˆ*Hashable Protocol*ï¼‰çš„ç±»å‹

```swift
Set<Hashable>
```

```swift
let s: Set<Int>

let s = Set<Int>()

let s: Set = [1, 2, 3] // å…ƒç´ æ˜¯æ— åºçš„
```

```swift
var s: Set = [1, 2, 3]

print(s.insert(4)) // (inserted: true, memberAfterInsert: 4)
print(s.insert(4)) // (inserted: false, memberAfterInsert: 4)

print(s.remove(4)) // Optional(4)
print(s.remove(10)) // nil

print(s.contains(1)) // true
print(s.count) // 3

print(s.sorted()) // è¿”å›æœ‰åºæ•°ç»„

// ç½®ç©º
print(s.removeAll()) // ()
// æˆ–
s = []
```

é›†åˆè¿ç®—

```swift
sa.intersection(sb) // äº¤é›†
sa.union(sb)        // å¹¶é›†
sa.subtracting(sb)  // å·®é›†
sa.subtract(sb)     // å‡é›†ï¼ˆä¿®æ”¹saï¼‰
sa.symmetricDifference(sb) // ç¯å’Œ/å¯¹ç§°å·®é›†
sa == sb // ç­‰é›†
sa.isSubnet(of: sb)         // å­é›†
sa.isStrictSubset(of: sb)   // çœŸå­é›†ï¼ˆä¸ç›¸ç­‰ï¼‰
sa.isSuperset(of: sb)       // è¶…é›†
sa.isStrictSuperset(of: sb) // çœŸè¶…é›†ï¼ˆä¸ç›¸ç­‰ï¼‰
sa.isDisjoint(with: sb)     // ä¸ç›¸äº¤é›†
```

#### å¯æ•£åˆ—ï¼ˆ*Hashable Protocol*ï¼‰

> æ•£åˆ—å€¼æ˜¯ä¸€ä¸ªæ•´å‹ï¼ˆ`Int`ï¼‰æ•°æ®

- åŸºç¡€ç±»å‹éƒ½å®ç°äº†å¯æ•£åˆ—åè®®

### å­—å…¸ï¼ˆDictionaryï¼‰

> é”®å€¼å…³è”çš„æ— åºé›†åˆã€‚

```swift
Dictionary<Hashable, Value>
```

```swift
// æ— åˆå§‹åŒ–å£°æ˜
let d: Dictionary<String, Int>
let d: [String: Int]

// å£°æ˜ç©ºå­—å…¸
let d = Dictionary<String, Int>()
let d = [String: Int]()
let d: Dictionary<String, Int> = [:]
let d: [String: Int] = [:]

// å­—é¢é‡
let d = ["foo": 1, "bar": 2]
```

```swift
// create
let dict = Dictionary<String, Int>()
let dict = [String: Int]()
let dict: [String: Int] = [:]
let dict: [String: String] = ["name": "lucky", "gender": "female"]
let dict = ["name": "lucky", "feeling": "good"]
// modify
dict["feeling"] = "great"
dict["gender"] = "female"
dict.updateValue("excellent", forKey: "feeling")!) // return Optional
// remove
dict.removeValue(forKey: "home") // return Optional
dict["home"] = nil
```

Iterate

```swift
for (key, value) in dict {}
for key in dict.keys {}
for value in dict.values {}
let arr = [String](dict.keys)
let arr = [String](dict.values.sorted())
```

# å¯ç©ºç±»å‹ï¼ˆOptionalï¼‰

> *Optional* è¡¨ç¤ºæŸç±»å‹ä¸æ˜¯ä¸€ç›´éƒ½å­˜åœ¨å€¼ã€‚ä¸€èˆ¬ç”¨äºå˜é‡å£°æ˜ã€ç±»å‹è½¬æ¢çš„è¿”å›å€¼ç­‰ã€‚

åœ¨ç±»å‹åæ·»åŠ `?`è¡¨ç¤ºæˆ–æœ‰ç±»å‹ï¼š

```swift
var a: Int?
assert(type(of: a) == Optional<Int>.self)
```

### ç©ºå€¼ï¼ˆ`nil`ï¼‰

> `nil`ä¸æ˜¯ä¸€ä¸ªç©ºæŒ‡é’ˆï¼Œå•çº¯æ˜¯è¯­æ³•å±‚é¢è¡¨ç¤ºå€¼ä¸å­˜åœ¨ã€‚

å¯ç©ºç±»å‹é»˜è®¤å€¼ä¸º`nil`

```swift
var a: Int?
assert(a == nil)
```

### å¯ç©ºç»‘å®šï¼ˆOptional Bindingï¼‰

> åˆ¤æ–­å¹¶å­˜å‚¨éç©ºå€¼äºä¸´æ—¶å˜é‡ä¸­å¹¶æ‰§è¡Œæ¡ä»¶è¯­å¥ã€‚ä¸€èˆ¬å‡ºç°åœ¨æ§åˆ¶è¯­å¥ä¸­ï¼Œå¦‚`if`, `switch`, `guard`, `while`ã€‚

```swift
var possibleNumber: Int? = 1
if let actualNumber = possibleNumber {
    print("The string \"\(possibleNumber)\" has an integer value of \(actualNumber)")
    // The string "Optional(1)" has an integer value of 1
}
```

### å¼ºåˆ¶è§£åŒ…ï¼ˆImplicitly Force Unwrappingï¼‰

> åœ¨æ˜ç¡®çŸ¥é“å¯ç©ºå€¼ä¸ä¸ºç©ºçš„æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨å¼ºåˆ¶è§£åŒ…è·å–å€¼ã€‚

```swift
var a: Int? = 1
assert(a == Optional(1))
assert(a! == 1)
```

### è‡ªåŠ¨è§£åŒ…å¯ç©ºç±»å‹ï¼ˆImplicitly Unwrapped Optionalsï¼‰

> å£°æ˜ä¸º**è‡ªåŠ¨è§£åŒ…å¯ç©ºç±»å‹**çš„å˜é‡åœ¨è·å–å€¼æ—¶æ— éœ€æ˜¾å¼è§£åŒ…ã€‚

```swift
var a: Int! = 1
// a ä»ç„¶æ˜¯Optional
assert(a == Optional(1))
// ä½†å¯ä»¥æ— éœ€è§£åŒ…ç›´æ¥ä½¿ç”¨ï¼š
let b: Int = a
```

### å¯ç©ºé“¾ï¼ˆOptional Chainingï¼‰

> å½“é‡è§ç©ºå€¼æ—¶ä¸­æ–­åç»­æ‰§è¡Œå¹¶è¿”å›`nil`ï¼Œä»è€Œæ— éœ€[è§£åŒ…ï¼ˆForced Unwrappingï¼‰](#å¼ºåˆ¶è§£åŒ…implicitly-force-unwrapping)ä»¥ç›´æ¥è®¿é—®å¯ç©ºå€¼çš„æˆå‘˜ï¼ˆå±æ€§ã€æ–¹æ³•ç­‰ï¼‰ã€‚

```swift
if let firstRoomName = john.residence?[0].name {
    print("The first room name is \(firstRoomName).")
}
if let johnsStreet = john.residence?.address?.street {
    print("John's street name is \(johnsStreet).")
}
if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    print("John's building identifier is \(buildingIdentifier).")
}
```

# æ–­è¨€ï¼ˆAssertionï¼‰

> æ–­è¨€å¤±è´¥å°†ç›´æ¥é€€å‡ºç¨‹åºã€‚

```swift
// æ™®é€šæ–­è¨€ä»…åœ¨è°ƒè¯•æ¨¡å¼ï¼ˆé€‰é¡¹`-Onone`ï¼‰ç”Ÿæ•ˆã€‚ï¼ˆé€‰é¡¹`-O`å¼€å¯æ—¶ä¼šè·³è¿‡ï¼Œé€‰é¡¹`-Ounchecked`å¼€å¯æ—¶æ¡ä»¶å§‹ç»ˆç¼–è¯‘ä¸º`true`ï¼‰ã€‚
assert(
    _ condition: @autoclosure () -> Bool,
    _ message: @autoclosure () -> String = String(),
    file: StaticString = #file,
    line: UInt = #line
)
assertionFailure(
    _ message: @autoclosure () -> String = String(),
    file: StaticString = #file,
    line: UInt = #line
)

// å…ˆå†³æ–­è¨€åœ¨å‘å¸ƒæ¨¡å¼ï¼ˆé€‰é¡¹`-O`ï¼‰ä¹Ÿç”Ÿæ•ˆã€‚ï¼ˆ`-Ounchecked`é€‰é¡¹å¼€å¯æ—¶æ¡ä»¶å§‹ç»ˆç¼–è¯‘ä¸º`true`ï¼‰ã€‚
precondition(
    _ condition: @autoclosure () -> Bool,
    _ message: @autoclosure () -> String = String(),
    file: StaticString = #file,
    line: UInt = #line
)
preconditionFailure(
    _ message: @autoclosure () -> String = String(),
    file: StaticString = #file,
    line: UInt = #line
) -> Never

// æ‰€æœ‰æ¨¡å¼ä¸‹å‡ç”Ÿæ•ˆï¼ˆæ¯”å¦‚ç”¨åœ¨è¿˜æœªéƒ¨ç½²çš„åŠŸèƒ½ä½œä¸ºå ä½å’Œæç¤º`fatalError("Unimplemented")`ï¼‰ã€‚
fatalError(
    _ message: @autoclosure () -> String = String(),
    file: StaticString = #file,
    line: UInt = #line
) -> Never
```

# é”™è¯¯å¤„ç†ï¼ˆError Handlingï¼‰

> æ‰€æœ‰é”™è¯¯å¿…é¡»éµå¾ª`Error`åè®®ã€‚

- ä¸ºäº†é¿å…å¤§é‡æ€§èƒ½æ¶ˆè€—ï¼ŒSwifté”™è¯¯å¤„ç†ä¸ä¼šè§£å¼€è°ƒç”¨æ ˆï¼ˆ~~unwinding call stack~~ï¼‰ï¼›

```swift
enum VendingMachineError: Error {
    case invalidSelection
    case insufficientFunds(coinsNeeded: Int)
    case outOfStock
}
```

## æŠ›å‡ºé”™è¯¯ï¼ˆ`throw`ï¼‰

> é€šè¿‡`throw`å…³é”®å­—æŠ›å‡ºé”™è¯¯ã€‚

```swift
throw VendingMachineError.insufficientFunds(coinsNeeded: 5)
```

## é”™è¯¯å¤„ç†

### é”™è¯¯å†’æ³¡ï¼ˆ`throws`ï¼‰

> é€šè¿‡`throws`å…³é”®å­—å£°æ˜å¯æŠ›é”™å‡½æ•°ã€‚

```swift
func canThrowErrors() throws -> String

func cannotThrowErrors() -> String
```

### ç›´æ¥å¤„ç†ï¼ˆ`do...catch`ï¼‰

> æ²¡æœ‰å£°æ˜ä¸ºå¯æŠ›é”™çš„å‡½æ•°å‡é¡»å¤„ç†é”™è¯¯ã€‚

```swift
do {
    try <#expression#>
    <#statements#>
} catch <#pattern 1#> {
    <#statements#>
} catch <#pattern 2#> where <#condition#> {
    <#statements#>
} catch <#pattern 3#>, <#pattern 4#> where <#condition#> {
    <#statements#>
} catch {
    <#statements#>
}
```

### è½¬æˆå¯ç©ºå€¼ï¼ˆ`try?`ï¼‰

> é€šè¿‡`try?`å…³é”®å­—æ‰§è¡Œå‡½æ•°ï¼Œè¿”å›Optionalï¼ˆåœ¨æŠ›é”™æ—¶è¿”å›`nil`ï¼‰ã€‚

```swift
let ret = try? vend() // "Success" or nil.
```

### é”™è¯¯æ–­è¨€ï¼ˆ`try!`ï¼‰

> é€šè¿‡`try!`å…³é”®å­—æ‰§è¡Œå‡½æ•°ï¼Œæ–­è¨€é”™è¯¯ä¸ä¼šå‘ç”Ÿï¼ˆæŠ›é”™æ—¶å°†å¾—åˆ°è¿è¡Œæ—¶é”™è¯¯ï¼‰ã€‚

```swift
let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg")
```

# æ“ä½œç¬¦ï¼ˆOperatorsï¼‰

> Swiftæ”¯æŒé‡è½½æ“ä½œç¬¦æ–¹æ³•ï¼Œä»¥åŠè‡ªå®šä¹‰æ“ä½œç¬¦ã€‚

## æ ‡å‡†æ“ä½œç¬¦

[Swiftæ ‡å‡†è¿ç®—ç¬¦](https://developer.apple.com/documentation/swift/operator-declarations)

æ ‡å‡†æ“ä½œç¬¦åŠæ“ä½œç¬¦ä¼˜å…ˆçº§[OperatorContext](https://github.com/apple/swift-format/blob/main/Sources/SwiftFormatPrettyPrint/OperatorContext.swift)

### å‰ç¼€è¿ç®—ç¬¦

- `+`ï¼ˆUnary Plusï¼‰
- `-`ï¼ˆUnary Minusï¼‰
- `!`ï¼ˆLogical NOTï¼‰
- `.!`ï¼ˆPointwise logical NOTï¼‰
- `~`ï¼ˆBitwise NOTï¼‰
- `..<`ï¼ˆPrefix Half-open Rangeï¼‰
- `...`ï¼ˆPrefix Closed Rangeï¼‰

### åç¼€è¿ç®—ç¬¦

- `...`ï¼ˆPostfix Half-open Rangeï¼‰

### ä¸­ç¼€è¿ç®—ç¬¦

#### BitwiseShiftPrecedence

- `<<`ï¼ˆBitwise left shiftï¼‰
- `&<<`ï¼ˆBitwise left shift, ignoring overflowï¼‰
- `>>`ï¼ˆBitwise right shiftï¼‰
- `&<<`ï¼ˆBitwise right shift, ignoring overflowï¼‰

#### MultiplicationPrecedence

- `*`ï¼ˆMultiplicationï¼‰
- `&*`ï¼ˆMultiplication with overflowï¼‰
- `/`ï¼ˆDivisionï¼‰
- `%`ï¼ˆRemainderï¼‰
- `&`ï¼ˆBitwise ANDï¼‰

#### AdditionPrecedence

- `+`ï¼ˆAdditionï¼‰
- `&+`ï¼ˆAddition with overflowï¼‰
- `-`ï¼ˆSubtractionï¼‰
- `&-`ï¼ˆSubtraction with overflowï¼‰
- `|`ï¼ˆBitwise ORï¼‰
- `^`ï¼ˆBitwise XORï¼‰

#### RangeFormationPrecedence

- `...`ï¼ˆClosed Rangeï¼‰
- `..<`ï¼ˆHalf-open Rangeï¼‰

#### CastingPrecedence

- `is`ï¼ˆType Checkï¼‰
- `as`ã€`as?`ã€`as!`ï¼ˆType castï¼‰

#### NilCoalescingPrecedence

- `??`ï¼ˆNil coalescingï¼‰

#### ComparisonPrecedence

- `<`ï¼ˆLess thanï¼‰
- `<=`ï¼ˆLess than or equalï¼‰
- `>`ï¼ˆGreater thanï¼‰
- `>=`ï¼ˆGreater than or equalï¼‰
- `==`ï¼ˆEqualï¼‰
- `!=`ï¼ˆNot equalï¼‰
- `===`ï¼ˆIdenticalï¼‰
- `!==`ï¼ˆNot identicalï¼‰
- `~=`ï¼ˆPattern Matchï¼‰
- `.<`ï¼ˆPointwise less thanï¼‰
- `.<=`ï¼ˆPointwise less than or equalï¼‰
- `.>`ï¼ˆPointwise greater thanï¼‰
- `.>=`ï¼ˆPointwise greater than or equalï¼‰
- `.==`ï¼ˆPointwise equalï¼‰
- `.!=`ï¼ˆPointwise not equalï¼‰

#### LogicalConjunctionPrecedence

- `&&`ï¼ˆLogical ANDï¼‰
- `.&`ï¼ˆPointwise bitwise ANDï¼‰

#### LogicalDisjunctionPrecedence

- `||`ï¼ˆLogical ORï¼‰
- `.|`ï¼ˆPointwise bitwise ORï¼‰
- `.^`ï¼ˆPointwise bitwise XORï¼‰

#### TernaryPrecedence

- `? :`ï¼ˆTernary Conditionalï¼‰

#### AssignmentPrecedence

- `=`ï¼ˆAssignï¼‰
- `*=`ï¼ˆMultiply and assignï¼‰
- `&*=`ï¼ˆMultiply with overflow and assignï¼‰
- `/=`ï¼ˆDivide and assignï¼‰
- `%=`ï¼ˆRemainder and assignï¼‰
- `+=`ï¼ˆAdd and assignï¼‰
- `&+=`ï¼ˆAdd with overflow and assignï¼‰
- `-=`ï¼ˆSubtract and assignï¼‰
- `&-=`ï¼ˆSubtract with overflow and assignï¼‰
- `<<=`ï¼ˆLeft bit shift and assignï¼‰
- `&<<=`ï¼ˆLeft bit shift ignoring overflow and assignï¼‰
- `>>=`ï¼ˆRight bit shift and assignï¼‰
- `&>>=`ï¼ˆRight bit shift ignoring overflow and assignï¼‰
- `&=`ï¼ˆBitwise AND and assignï¼‰
- `&|`ï¼ˆBitwise OR and assignï¼‰
- `^=`ï¼ˆBitwise XOR and assignï¼‰
- `.&=`ï¼ˆPointwise bitwise AND and assignï¼‰
- `.|=`ï¼ˆPointwise bitwise OR and assignï¼‰
- `.^=`ï¼ˆPointwise bitwise XOR and assignï¼‰

å¤šå…ƒè¿ç®—ç¬¦çš„ç¬¦å·ä¸¤è¾¹çš„ç©ºæ ¼è¦æ±‚ä¸€è‡´ï¼š

```swift
print(1 + 1) // 2
print(1+1) // 2
print(1 +1) // error
print(1+ 1) // error
```

## èµ‹å€¼

èµ‹å€¼ï¼ˆ`=`ï¼‰ä¸ä¼š~~è¿”å›å€¼~~ï¼š

```swift
if x = y {} // error
```

èµ‹å€¼å¯ä»¥è§£æ„ï¼š

```swift
let (x, y) = (1, 2)
```
## ç©ºåˆå¹¶ï¼ˆNil-Coalescingï¼‰

> `??`

ç­‰åŒäº

```swift
a != nil ? a! : b
```

## åŒºé—´ï¼ˆRange Operatorï¼‰

é—­åŒºé—´ï¼ˆClosed Rangeï¼‰

```swift
print(type(of: 1...2)) // ClosedRange<Int>
```

åŠå¼€åŒºé—´ï¼ˆHalf-open Rangeï¼‰

```swift
print(type(of: 1..<2)) // Range<Int>
```

å‰ç¼€åŠå¼€åŒºé—´ï¼ˆPrefix Half-open Rangeï¼‰

```swift
print(type(of: ..<2)) // PartialRangeUpTo<Int>
```

å‰ç¼€é—­åŒºé—´ï¼ˆPrefix Closed Rangeï¼‰

```swift
print(type(of: ...2)) // PartialRangeThrough<Int>
```

åç¼€é—­åŒºé—´ï¼ˆPostfix Closed Rangeï¼‰

```swift
print(type(of: 1...)) // PartialRangeFrom<Int>
```

```swift
// Closed Range
for i in 1...5 { print(i) }

// Half-Open Range
for i in 1..<5 { print(i) }

// One-Sided
let a = [1, 2, 3, 4, 5]
for i in a[1...]
for i in a[...3] { print(i) }

for e in 1... {
  if e > 10 { break }
}
```

## é€»è¾‘ï¼ˆLogical Operatorï¼‰

> `!`, `&&`, `||`

# æ§åˆ¶æµç¨‹ï¼ˆControl Flowï¼‰

> [æ§åˆ¶æµç¨‹][controlflow]

## `for...in`

> ç”¨äºè‡ªåŠ¨è¿­ä»£å®ç°äº†åºåˆ—ï¼ˆ`Sequence`ï¼‰åè®®çš„æ•°æ®ï¼Œå¦‚åŒºé—´ã€å­—ç¬¦ä¸²ã€æ•°ç»„ã€å­—å…¸ç­‰ç­‰ã€‚

```swift
// åŒºé—´
for i in 1...5 { <#statements#> }
// æ•°ç»„
for e in [1, 2, 3] { <#statements#> }
// å­—å…¸ï¼ˆæ³¨æ„ï¼Œå­—å…¸æœ¬èº«æ˜¯æ— åºçš„ï¼‰
for (animalName, legCount) in ["spider": 8, "ant": 6, "cat": 4] { <#statements#> }
```

å¿½ç•¥è¿­ä»£é¡¹ï¼š

```swift
for _ in 1...5 { <#statements#> }
```

é€šè¿‡`where`å®ç°æ¡ä»¶è¿­ä»£ï¼š

```swift
for i in 1...5 where 1 % 3 == 0 { <#statements#> }
```

## `while`

```swift
while <#condition#> {
   <#statements#>
}
```

## `repeat...while`

```swift
repeat {
   <#statements#>
} while <#condition#>
```

## `if`

```swift
if <#condition#> { <#statements#> }
if <#condition#> { <#statements#> } else { <#statements#> }
if <#condition#> { <#statements#> } else if <#condition#> { <#statements#> }
if case 10...16 = age {}
if case 10...16 = age, age > 25 {}
```

## `switch`

- ä¸€æ—¦åŒ¹é…åˆ°ï¼Œå°±ä¸å†ç»§ç»­åŒ¹é…
- å¿…é¡»æœ‰`default`åˆ†æ”¯
- ä¸å…è®¸å­˜åœ¨ç©ºåˆ†æ”¯ï¼Œå¯ä»¥ç”¨`break`è¯­å¥å¡«å……

```swift
switch <#expression#> {
  case <#expression#>:
    <#statements#>
  // å¤šä¸ªåŒ¹é…é¡¹
  case <#expression#>, <#expression#>:
    <#statements#>
  // switchä¸å…è®¸ç©ºçš„æ‰§è¡Œè¯­å¥ï¼Œå¯ä»¥ä½¿ç”¨`break`å¡«å……
  case <#expression#>:
    break
  // é»˜è®¤é¡¹
  default:
    <#statements#>
}
```

### ç©¿é€ç›¸é‚»åˆ†æ”¯ï¼ˆ`fallthrough`ï¼‰

> `fallthrough`ï¼šç«‹å³é€€å‡ºå½“å‰åˆ†æ”¯çš„æ‰§è¡Œï¼Œå¹¶è·³å…¥ä¸‹ä¸ªç›¸é‚»çš„åˆ†æ”¯ï¼ˆä¸æ£€æŸ¥åˆ†æ”¯æ¡ä»¶ï¼‰ç»§ç»­æ‰§è¡Œã€‚

```swift
let integerToDescribe = 5
var description = "The number \(integerToDescribe) is"
switch integerToDescribe {
  case 1...:
    description += " greater than 1, and also"
    fallthrough
  case 10...:
    description += " greater than 10, and also"
    fallthrough
  default:
    description += " an integer."
}
print(description) // The number 5 is greater than 1, and also greater than 10, and also an integer.
```

### åŒ¹é…å€¼åŒºé—´ï¼ˆInterval Matchingï¼‰

```swift
case 5...10:
  <#statements#>
case 1..<5, 11...20:
  <#statements#>
```

### é€šè¿‡å…ƒç»„æµ‹è¯•å¤šä¸ªå€¼

```swift
let somePoint = (1, 1)
switch somePoint {
  case (0, 0):
      print("\(somePoint) is at the origin")
  case (_, 0):
      print("\(somePoint) is on the x-axis")
  case (0, _):
      print("\(somePoint) is on the y-axis")
  case (-2...2, -2...2):
      print("\(somePoint) is inside the box")
  default:
      print("\(somePoint) is outside of the box")
}
```

### å€¼ç»‘å®šï¼ˆValue Bindingsï¼‰

```swift
switch (2, 0) {
  case (let x, 0):
      print("on the x-axis with an x value of \(x)")
  case (0, let y):
      print("on the y-axis with a y value of \(y)")
  case let (x, y):
      print("somewhere else at (\(x), \(y))")
}
```
```swift
indirect enum ArithmeticExpression {
  case number(Int)
  case addition(ArithmeticExpression, ArithmeticExpression)
  case multiplication(ArithmeticExpression, ArithmeticExpression)
}
func evaluate(_ expression: ArithmeticExpression) -> Int {
  switch expression {
  case let .number(value):
    return value
  case let .addition(left, right):
    return evaluate(left) + evaluate(right)
  case let .multiplication(left, right):
    return evaluate(left) * evaluate(right)
  }
}
```

### é€šè¿‡`where`ç»†åŒ–åŒ¹é…æ¡ä»¶ï¼š

```swift
let yetAnotherPoint = (1, -1)
switch yetAnotherPoint {
case let (x, y) where x == y:
    print("(\(x), \(y)) is on the line x == y")
case let (x, y) where x == -y:
    print("(\(x), \(y)) is on the line x == -y")
case let (x, y):
    print("(\(x), \(y)) is just some arbitrary point")
}
```

- fallthrough doesn't check the case condition of it causes execution fall into

- value bindings are available in the fallen into

## `guard...else`

> å¦‚æœ`guard`è¯­å¥çš„æ¡ä»¶ä¸æ»¡è¶³æ—¶ï¼Œæ‰§è¡Œ`else`è¯­å¥å¹¶æå‰é€€å‡ºå½“å‰åŸŸçš„æ‰§è¡Œã€‚

- `guard...else`è¯­å¥ç±»ä¼¼ç”Ÿäº§æ¨¡å¼ä¸‹çš„`assert`
- `Optional`å˜é‡ç»è¿‡`guard`è¯­å¥å®¡æŸ¥ååç»­å¯ä»¥åœ¨æ‰€åœ¨åŸŸç›´æ¥ä½¿ç”¨
- `else`åˆ†æ”¯å¿…é¡»è½¬ç§»æ‰€åœ¨åŸŸçš„æ§åˆ¶æƒï¼ˆ`return`, `break`, `continue`, `throw`, `fatalError`...ï¼‰

```swift
func greet(person: [String: String]) {
  guard let name = person["name"] else {
    return
  }

  print("Hello \(name)!")

  guard let location = person["location"] else {
    print("I hope the weather is nice near you.")
    return
  }

  print("I hope the weather is nice in \(location).")
}
```

## `defer`

> [defer](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/errorhandling#Specifying-Cleanup-Actions)è¯­å¥åœ¨ä½œç”¨åŸŸç»“æŸå‰è°ƒç”¨ã€‚

- `defer`è¯­å¥å¯ä»¥æœ‰å¤šä¸ªï¼Œå¹¶æŒ‰å€’åºæ‰§è¡Œï¼›
- `defer`è¯­å¥ä¸­ä¸èƒ½æœ‰~~è½¬ç§»æ§åˆ¶è¯­å¥ï¼ˆå¦‚`return`, `break`ï¼‰~~ï¼›
- `defer`è¯­å¥ä¸­ä¸èƒ½~~æŠ›é”™~~ï¼›

```swift
func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // Work with the file.
        }
        // close(file) is called here, at the end of the scope.
    }
}
```

## è¯­å¥æ ‡ç­¾ï¼ˆlabelï¼‰

```swift
<#label#>: while <#condition#> {
   <#statements#>
}
```

## æ£€æŸ¥ç¯å¢ƒ

`#available`

```swift
#available(<#platform name#> <#version#>, <#...#>, *)
```

```swift
// `*` è¡¨ç¤ºå…¶ä»–å¹³å°
if #available(iOS 10, macOS 10.12, *) {
    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS
} else {
    // Fall back to earlier iOS and macOS APIs
}
```

`#unavailable`

```swift
if #unavailable(iOS 10) {
    // Fallback code
}
```

åœ¨`guard...else`ä¸­ä½¿ç”¨ï¼š

```swift
@available(macOS 10.12, *)
struct ColorPreference {
    var bestColor = "blue"
}

func chooseBestColor() -> String {
    guard #available(macOS 10.12, *) else {
       return "gray"
    }
    let colors = ColorPreference()
    return colors.bestColor
}
```

# å‡½æ•°ï¼ˆFunctionsï¼‰

```swift
func [functionName]([parameterLabel|_] [parameter: type] = [defaultValue] ...) [throws] [-> type] { }
```

> [å‡½æ•°][functions] varies in `parameter label`, `parameter type`, and `return type`.

```swift
// æ— è¿”å›å€¼ï¼ˆå³è¿”å›`Void`ï¼Œå³ç©ºå…ƒç»„`()`ï¼‰
func a () {}
func a2 () -> Void {}
func a3 () -> () {}

// æœ‰è¿”å›å€¼
func b() -> Int { return 1 }

// é€šè¿‡å…ƒç»„å¯ä»¥è¿”å›å¤šä¸ªå€¼
func r() -> (Int, Int) { return (1, 2) }
print(f()) // (1, 2)
func r2() -> (x: Int, y: Int) { return (3, 4) }
print(g()) // (x: 1, y: 2)

// å‡½æ•°å‚æ•°
// - å‡½æ•°è°ƒç”¨æ—¶å‚æ•°é»˜è®¤éœ€è¦å…·åï¼ˆå¸¦å‚æ•°æ ‡ç­¾ï¼‰ä¼ é€’
// - å‡½æ•°å‚æ•°é»˜è®¤æ˜¯å¸¸é‡
func p(a: Int) -> Int { return a + 1 }
p(a: 1)

// ä¿®æ”¹å‚æ•°æ ‡ç­¾ï¼Œå³è°ƒç”¨å‡½æ•°æ—¶æ‰€ä½¿ç”¨çš„å‚æ•°åç§°
func pl(x a: Int) -> Int { return a + 1 }
pl(x: 1)

// çœç•¥å‚æ•°æ ‡ç­¾ï¼Œå¯ä»¥å®ç°åŒ¿åä¼ å‚
func pa(_ a: Int) -> Int { return a + 1 }
pa(1)

// å‚æ•°é»˜è®¤å€¼ï¼Œæœ‰é»˜è®¤å€¼çš„å‚æ•°ä¸è¦æ±‚æ”¾åœ¨åé¢
func pd(a: Int = 1, b: Int) -> Int { return a + b }
pd(b: 1)

// ä¸å®šå‚æ•°ï¼Œåœ¨å‡½æ•°ä½“ä¸­å½“ä½œæ•°ç»„æä¾›
func pv(a: Int...) {}

// å¤šä¸ªä¸å®šå‚æ•°ï¼Œéœ€è¦åœ¨ä¸å®šå‚æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°åŠ ä¸Šå‚æ•°æ ‡ç­¾ä»¥åŒºåˆ†
func pv2(a: Int..., b: Int...) {}
pv2(a: 1, 2)
pv2(a: 1, 2, b: 3, 4)
```

## å¯ä¿®æ”¹å‚æ•° (`inout`)

> å‡½æ•°çš„å‚æ•°é»˜è®¤æ˜¯å¸¸é‡ï¼Œå¦‚æœè¦ä¿®æ”¹ï¼Œéœ€è¦å£°æ˜å‚æ•°ç±»å‹ä¸ºå¯`inout`ç±»å‹ï¼Œå¹¶åœ¨è°ƒç”¨å‡½æ•°æ—¶ä¼ å…¥å¼•ç”¨å€¼ï¼ˆ`&`ï¼‰ã€‚

å¯å˜å‚æ•°å®é™…æ˜¯åœ¨è°ƒç”¨å‡½æ•°æ—¶ä¼ å…¥äº†å‚æ•°å‰¯æœ¬ï¼Œå¹¶åœ¨å‡½æ•°ç»“æŸåå°†å‰¯æœ¬èµ‹å€¼ç»™åŸå˜é‡ï¼Œæ•…ï¼š

- `inout`å‚æ•°ä¸èƒ½æœ‰~~é»˜è®¤å€¼~~ï¼Œä¹Ÿä¸èƒ½æ˜¯~~ä¸å®šå‚æ•°~~
- `inout`å‚æ•°å¿…é¡»ä¼ å…¥å˜é‡ï¼Œä¸èƒ½ä¼ å…¥~~å¸¸é‡~~å’Œ~~å­—é¢é‡~~

```swift
func swap(_ a: inout Int, _ b: inout Int) {
  (a, b) = (b, a)
}
var x = 3, y = 107
swap(&x, &y)
print("x is now \(x), and y is now \(y)")
// Prints "x is now 107, and y is now 3"
```

ç”±äºSwiftç¼–è¯‘å™¨ä¸ºäº†ä¼˜åŒ–æ€§èƒ½ï¼Œåœ¨å¤„ç†çš„æ—¶å€™ä¼ å…¥çš„æ˜¯å¼•ç”¨ï¼Œæ•…ï¼š

- ä½œä¸º`inout`å‚æ•°ä¼ å…¥çš„å˜é‡ä¸èƒ½åœ¨å¤šçº¿ç¨‹çš„æ—¶å€™ç›´æ¥è®¿é—®
- åŒä¸€ä¸ªå˜é‡ä¸èƒ½åŒæ—¶ä½œä¸ºå¤šä¸ª`inout`å‚æ•°ä¼ å…¥

```swift
func multithreadedFunction(queue: DispatchQueue, x: inout Int) {
  // Make a local copy and manually copy it back.
  var localX = x
  defer { x = localX }

  // Operate on localX asynchronously, then wait before returning.
  queue.async { someMutatingOperation(&localX) }
  queue.sync {}
}
```

## å‡½æ•°ç±»å‹

> å‡½æ•°ç±»å‹ç”±å‡½æ•°å‚æ•°ç±»å‹å’Œå‡½æ•°è¿”å›å€¼ç±»å‹å…±åŒå†³å®šã€‚

```swift
func a(_ x: Int) -> String { "" }
print(type(of: a)) // (Int) -> String
```

### å‡½æ•°å˜é‡

é€šè¿‡å‡½æ•°ç±»å‹å¯ä»¥å®šä¹‰å‡½æ•°å˜é‡ï¼Œä»¥åŠ¨æ€è°ƒç”¨å‡½æ•°ï¼š

```swift
var mathFunction: (Int, Int) -> Int = addTwoInts
```

### é«˜é˜¶å‡½æ•°

é€šè¿‡å°†å‚æ•°æˆ–è¿”å›å€¼å®šä¹‰ä¸ºå‡½æ•°ç±»å‹å¯ä»¥å®šä¹‰é«˜é˜¶å‡½æ•°ï¼š

```swift
func printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    print("Result: \(mathFunction(a, b))")
}
```

```swift
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    return backward ? stepBackward : stepForward
}
```

## å†…è”å‡½æ•°

> å‡½æ•°å†…å¯ä»¥å®šä¹‰å†…è”å‡½æ•°ï¼Œå†…è”å‡½æ•°å¯ä»¥ç›´æ¥ä½¿ç”¨æ‰€åœ¨å‡½æ•°ä¸­çš„é¡¹ç›®ï¼Œå¹¶å¯ä»¥ä½œä¸ºè¿”å›å€¼è¢«è¿”å›ã€‚

```swift
func chooseStepFunction(backward: Bool) -> (Int) -> Int {
    func stepForward(input: Int) -> Int { return input + 1 }
    func stepBackward(input: Int) -> Int { return input - 1 }
    return backward ? stepBackward : stepForward
}
```

## (v5.1) éšå¼è¿”å›ï¼ˆimplicit returnï¼‰

> å¦‚æœå‡½æ•°ä½“åªæœ‰ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œåˆ™å¯ä»¥çœç•¥`return`.ï¼ˆIf the entire body of the function is a single expression, the function implicitly returns that expression.ï¼‰

```swift
func greet(name: String) -> String {
  "Hello! \(name)."
}
```

# é—­åŒ…ï¼ˆClosuresï¼‰

> [é—­åŒ…][closures]ï¼šæ•è·å¹¶å¯*æŒç»­*ï¼ˆå³ä½¿è¿™äº›å˜é‡çš„åŸå§‹ä¸Šä¸‹æ–‡å·²ç»ä¸å­˜åœ¨äº†ï¼‰è¯»å–å¤–éƒ¨å˜é‡çš„*è‡ªåŒ…å«åŠŸèƒ½å—*ï¼ˆå³å‡½æ•°ï¼ŒåŒºåˆ«äºä¸æ™®é€šä»£ç å—ï¼‰ã€‚
> ï¼ˆ*Closures are self-contained blocks of functionality that can be passed around and used in your code. Closures can capture and store references to any constants and variables from the context in which theyâ€™re defined.*ï¼‰

é—­åŒ…æœ‰ä¸‰ç§ï¼Œå…¶ä¸­*å‡½æ•°ï¼ˆFunctionsï¼‰* å’Œ *å†…è”å‡½æ•°ï¼ˆNested Functionsï¼‰*æ˜¯ä¸¤ç§ç‰¹æ®Šé—­åŒ…ï¼Œç¬¬ä¸‰ç§å³**é—­åŒ…ï¼ˆè¡¨è¾¾å¼ï¼‰**ã€‚

## é—­åŒ…è¡¨è¾¾å¼ï¼ˆClosure Expressionsï¼‰

> é—­åŒ…è¡¨è¾¾å¼å®é™…æ˜¯è¢«Swifté’ˆå¯¹æ€§åœ°åšäº†äº›ç®€åŒ–çš„åŒ¿åé—­åŒ…ï¼Œä»¥æ–¹ä¾¿ä½¿ç”¨ï¼Œå¦‚ï¼š

- é€šè¿‡ä¸Šä¸‹æ–‡è‡ªåŠ¨æ¨å¯¼å‚æ•°ç±»å‹ï¼ˆ*Inferring parameter and return value types from context*ï¼‰
- å•è¡¨è¾¾å¼å¯ä»¥çœç•¥`return`ï¼ˆ*Implicit returns from single-expression closures*ï¼‰
- é€šè¿‡é­”æœ¯å˜é‡çœç•¥å‚æ•°å®šä¹‰ï¼ˆ*Shorthand Argument Names*ï¼‰
- å°¾éšé—­åŒ…è¯­æ³•ï¼ˆ*Trailing closure syntax*ï¼‰

éœ€è¦æ³¨æ„çš„æ˜¯ï¼š

- é—­åŒ…å‚æ•°ä¸èƒ½æœ‰é»˜è®¤å€¼

```swift
{ (<#parameters#>) -> <#return type#> in
   <#statements#>
}
```

```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

// å®Œæ•´é—­åŒ…å†™æ³•
names.sorted(by: { (a: String, b: String) -> Bool in return a > b })

// é€šè¿‡ä¸Šä¸‹æ–‡è‡ªåŠ¨æ¨å¯¼å‚æ•°ç±»å‹ï¼ˆ*Inferring Type From Context*ï¼‰
names.sorted(by: { (a, b) -> Bool in a > b })

names.sorted(by: { a, b -> Bool in a > b })

// å•è¡¨è¾¾å¼å¯ä»¥çœç•¥`return`ï¼ˆ*Implicit Returns from Single-Expression Closures*ï¼‰
names.sorted(by: { (a: String, b: String) -> Bool in a > b })

// é€šè¿‡é­”æœ¯å˜é‡çœç•¥å‚æ•°å®šä¹‰ï¼ˆ*Shorthand Argument Names*ï¼‰
names.sorted(by: { $0 > $1 })

// ç›´æ¥ä½¿ç”¨æ“ä½œç¬¦æ–¹æ³•ï¼ˆ*Operator Methods*ï¼‰
names.sorted(by: >)
```

## å°¾éšé—­åŒ…ï¼ˆTrailing Closuresï¼‰

> å¦‚æœé—­åŒ…ä½œä¸ºå‡½æ•°æœ€åä¸€ä¸ªæˆ–å¤šä¸ªå‚æ•°ï¼Œåˆ™è¯¥é—­åŒ…å¯ä»¥å†™åœ¨å‡½æ•°è°ƒç”¨çš„æ‹¬å·å¤–ï¼Œå…¶ä¸­ï¼Œç¬¬ä¸€ä¸ªå°¾éšé—­åŒ…å¯ä»¥ä¸ç”¨å‚æ•°æ ‡ç­¾æ ‡æ³¨ã€‚

```swift
names.sorted() { $0 > $1 }
```

> å¦‚æœå‡½æ•°ä»…æœ‰è¯¥é—­åŒ…ä¸€ä¸ªå‚æ•°ï¼Œåˆ™å¯ä»¥çœç•¥å‡½æ•°è°ƒç”¨çš„æ‹¬å·`()`ã€‚

```swift
names.sorted { $0 > $1 }
```

> å°¾éšé—­åŒ…å¯ä»¥æœ‰å¤šä¸ªï¼Œä½†é™¤äº†ç¬¬ä¸€ä¸ªå¤–ï¼Œå…¶ä½™å‡é¡»ä½¿ç”¨å‚æ•°æ ‡ç­¾æ ‡æ³¨ã€‚

```swift
func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {
    if let picture = download("photo.jpg", from: server) {
        completion(picture)
    } else {
        onFailure()
    }
}
loadPicture(from: someServer) { picture in
    someView.currentPicture = picture
} onFailure: {
    print("Couldn't download the next picture.")
}
```

## é€ƒé€¸é—­åŒ…ï¼ˆEscaping Closuresï¼‰

> ä¼ å…¥äº†å‡½æ•°ä½†åœ¨å‡½æ•°è¿”å›åæ‰ä¼šè°ƒç”¨çš„é—­åŒ…ã€‚ï¼ˆ*A closure is said to escape a function when the closure is passed as an argument to the function, but is called after the function returns.*ï¼‰

é€ƒé€¸é—­åŒ…éœ€è¦åœ¨å…¶ç±»å‹å‰æ ‡è®° `@escaping`ï¼š

```swift
var completionHandlers: [() -> Void] = []
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
```

å½“é€ƒé€¸é—­åŒ…ä¸­éœ€è¦å¼•ç”¨*ç±»å®ä¾‹*ï¼ˆ`self`ï¼‰çš„å±æ€§æˆ–æ–¹æ³•æ—¶ï¼Œéœ€è¦æ˜ç¡®é€šè¿‡`self`å¼•ç”¨ï¼š

```swift
class SomeClass {
    var x = 10
    func doSomething() {
        // é€ƒé€¸é—­åŒ…
        someFunctionWithEscapingClosure { self.x = 100 }
        // æˆ–
        someFunctionWithEscapingClosure { [self] in x = 100 }
        // æ™®é€šé—­åŒ…
        someFunctionWithNonescapingClosure { x = 200 }
    }
}
```

## è‡ªåŠ¨é—­åŒ…ï¼ˆAutoclosuresï¼‰

> ä¸€ç§è‡ªåŠ¨åˆ›å»ºçš„é—­åŒ…ï¼šå¦‚æœä¸€ä¸ªé—­åŒ…æ²¡æœ‰å‚æ•°çš„è¯ï¼Œå¯ä»¥çœç•¥å‚æ•°å£°æ˜éƒ¨åˆ†ï¼Œåªå†™é—­åŒ…ä½“éƒ¨åˆ†ï¼ˆ`{ statement }`ï¼‰ï¼Œä¼šè¢«è‡ªåŠ¨åˆ›å»ºæˆé—­åŒ…ã€‚(*An autoclosure is a closure thatâ€™s automatically created to wrap an expression thatâ€™s being passed as an argument to a function. It doesnâ€™t take any arguments, and when itâ€™s called, it returns the value of the expression thatâ€™s wrapped inside of it.*)

```swift
let customer = { customersInLine.remove(at: 0) }

func serve(customer customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: customer)
```

> é€šè¿‡åœ¨é—­åŒ…ç±»å‹å‰å£°æ˜`@autoclosure`ï¼Œå¯ä»¥çœç•¥é—­åŒ…ä½“~~æ ‡è¯†ç¬¦ï¼ˆ`{}`ï¼‰~~ï¼š

```swift
func serve(customer customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}
serve(customer: customersInLine.remove(at: 0))
```

## æ•è·åˆ—è¡¨ï¼ˆCapturing Listï¼‰

> å½“é—­åŒ…äº§ç”Ÿ[å¼ºå¼•ç”¨å¾ªç¯][Strong-Reference-Cycles-for-Closures]ï¼ˆå¦‚åœ¨ç±»ä¸­é€šè¿‡é—­åŒ…å®šä¹‰æ–¹æ³•ï¼Œæ–¹æ³•ä¸­å¯¹å®ä¾‹è¿›è¡Œå¼•ç”¨ï¼‰æ—¶ï¼Œå¯é€šè¿‡å®šä¹‰æ•è·åˆ—è¡¨çš„æ‰‹æ®µï¼Œå®šä¹‰é—­åŒ…å¯¹å®ä¾‹ï¼ˆæˆ–å±æ€§ã€æ–¹æ³•ï¼‰çš„å¼±å¼•ç”¨æˆ–éæ‹¥æœ‰å…³ç³»ã€‚

- `unowned`ï¼Œéæ‹¥æœ‰å¼•ç”¨ï¼šå®ä¾‹å’Œé—­åŒ…åŒæ—¶é‡Šæ”¾ï¼›
- `weak`ï¼Œå¼±å¼•ç”¨ï¼šé—­åŒ…å¯ä»¥å­˜ç»­æ›´ä¹…ï¼Œå¼•ç”¨å¯èƒ½ä¸ºç©º`nil`ï¼›

```swift
lazy var someClosure = {
        [unowned self, weak delegate = self.delegate]
        (index: Int, stringToProcess: String) -> String in
    // closure body goes here
}
// å½“é—­åŒ…æ²¡æœ‰å‚æ•°å’Œè¿”å›å€¼æ—¶ï¼š
lazy var someClosure2 = {
        [unowned self, weak delegate = self.delegate] in
    // closure body goes here
}
```

ä¾‹å¦‚ï¼š

```swift
class HTMLElement {

    let name: String
    let text: String?

    lazy var asHTML: () -> String = {
            [unowned self] in
        if let text = self.text {
            return "<\(self.name)>\(text)</\(self.name)>"
        } else {
            return "<\(self.name) />"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
    }

    deinit {
        print("\(name) is being deinitialized")
    }

}
```

# æšä¸¾ï¼ˆEnumerationsï¼‰

> [æšä¸¾ï¼ˆEnumerationsï¼‰][enumerations]ï¼šï¼ˆ*An enumeration defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.*ï¼‰

- å¯ä»¥å®šä¹‰[æšä¸¾é¡¹åŸå§‹å€¼](#æšä¸¾é¡¹åŸå§‹å€¼raw-values)
- å¯ä»¥å®šä¹‰[æšä¸¾é¡¹å…³è”å€¼](#æšä¸¾é¡¹å…³è”å€¼associated-values)ï¼›
- å¯ä»¥å®šä¹‰[åˆå§‹åŒ–å™¨](#åˆå§‹åŒ–initializations)ï¼›
- å¯ä»¥å®šä¹‰[è®¡ç®—å±æ€§](#è®¡ç®—å±æ€§computed-properties)ï¼›
- å¯ä»¥å®šä¹‰[æ–¹æ³•](#æ–¹æ³•methods)ï¼›
- å¯ä»¥[æ‰©å±•](#æ‰©å±•extension)åŸå§‹å®ç°ï¼›
- å¯ä»¥å£°æ˜ç¬¦åˆ[åè®®](#åè®®protocol)ä»¥æä¾›æ ‡å‡†åŠŸèƒ½ï¼›

```swift
enum CompassPoint {
  case east
  case south
  case west
  case north
}
```

å¤šä¸ªæšä¸¾é¡¹å¯ä»¥å†™åœ¨ä¸€è¡Œ

```swift
enum CompassPoint {
  case east, south, west, north
}
```

å½“å·²çŸ¥å˜é‡æšä¸¾ç±»å‹æ—¶ï¼Œå¯ä»¥ç®€å†™æšä¸¾é¡¹èµ‹å€¼ï¼š

```swift
var point = CompassPoint.east
point = .south
```

## æšä¸¾é¡¹åŸå§‹å€¼ï¼ˆRaw Valuesï¼‰

> åŸå§‹å€¼æ˜¯æšä¸¾é¡¹æ‰€å¯¹åº”çš„å›ºå®šå€¼ï¼Œç”¨ä»¥é™æ€å­˜å‚¨æ•°æ®ã€‚

æšä¸¾çš„åŸå§‹å€¼ç±»å‹å¯ä»¥æ˜¯å­—ç¬¦ä¸²ã€å­—ç¬¦ã€æ•´æ•°ã€æµ®ç‚¹æ•°ï¼›

```swift
enum Weekday: Int {
  case monday = 1
  case tuesday = 2
  case wednesday = 3
  case thursday = 4
  case friday = 5
}
```

éšå¼åŸå§‹å€¼ï¼ˆImplicit Raw Valuesï¼‰

> `Integer` and `String` have implicit raw value, while Integer is one more than previous case value, and String is the case name.

```swift
enum Weekday: Int {
  case monday = 1
  case tuesday // 2
  case wednesday = 10 // 10
  case thursday // 11
  case friday // 12
}
```

ä½¿ç”¨åŸå§‹å€¼åˆå§‹åŒ–æšä¸¾ï¼ˆInitializing from Raw Valuesï¼‰ï¼Œç”Ÿæˆçš„æšä¸¾æ˜¯`Optional`

```swift
let day = WeekDay(rawValue: 1) // Optional(WeekDay.monday)
let day2 = WeekDay(rawValue: 5) // nil
```

## æšä¸¾é¡¹å…³è”å€¼ï¼ˆAssociated Valuesï¼‰

> ä¸åŸå§‹å€¼ç›¸å¯¹åœ°ï¼Œé€šè¿‡å…³è”å€¼å¯ä»¥åœ¨æšä¸¾é¡¹åŠ¨æ€å­˜å‚¨æ•°æ®ã€‚

```swift
enum Barcode {
  case upc(Int, Int, Int, Int)
  case qrCode(String)
}
```

å¯ä»¥é€šè¿‡`switch`è¯­å¥å®¡æŸ¥æšä¸¾ï¼Œå¹¶è§£åŒ…å…³è”å€¼ï¼š

```swift
switch productBarcode {
  case .upc(let numberSystem, let manufacturer, let product, let check):
  // è‹¥æ‰€æœ‰è§£åŒ…å€¼çš„å¯å˜æ€§ç›¸åŒï¼Œè¿˜å¯ä»¥å†™æˆï¼š
  // case let .upc(numberSystem, manufacturer, product, check):
    print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")
  case .qrCode(let productCode):
    print("QR code: \(productCode).")
}
```

## å¯è¿­ä»£æšä¸¾é¡¹ï¼ˆIterable Casesï¼‰

é€šè¿‡éƒ¨ç½²`CaseIterable`[åè®®](#åè®®protocol)ï¼Œå¯ä»¥å®ç°æšä¸¾é¡¹çš„è¿­ä»£ã€‚

```swift
enum CompassPoint: CaseIterable {
  case east, south, west, north
}
for beverage in Beverage.allCases {
    print(beverage)
}
```

## é€’å½’æšä¸¾ï¼ˆRecursive Enumerationsï¼‰

```swift
enum ArithmeticExpression {
  case number(Int)
  indirect case addition(ArithmeticExpression, ArithmeticExpression)
  indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
}
```

æˆ–

```swift
indirect enum ArithmeticExpression {
  case number(Int)
  case addition(ArithmeticExpression, ArithmeticExpression)
  case multiplication(ArithmeticExpression, ArithmeticExpression)
}
```

# ç»“æ„ï¼ˆStructuresï¼‰å’Œç±»ï¼ˆClassesï¼‰

> [ç»“æ„ï¼ˆStructureï¼‰å’Œç±»ï¼ˆClassï¼‰][classesandstructures]åœ¨å®šä¹‰ã€è°ƒç”¨ç­‰æ–¹é¢åŸºæœ¬ç›¸åŒï¼Œå¯ä»¥å®šä¹‰å±æ€§ã€æ–¹æ³•ã€åˆå§‹åŒ–å™¨ã€æ‰©å±•é»˜è®¤å®ç°ã€å®ç°åè®®ç­‰ï¼Œä¹Ÿéƒ½æ˜¯é€šè¿‡ä¸‹æ ‡è°ƒç”¨å€¼ã€‚

*ç»“æ„ï¼ˆStructureï¼‰å’Œç±»ï¼ˆClassï¼‰*çš„ç›¸åŒç‚¹ï¼š

- å®šä¹‰[å±æ€§ï¼ˆPropertiesï¼‰](#å±æ€§properties)ï¼›
- å®šä¹‰[æ–¹æ³•ï¼ˆMethodsï¼‰](#æ–¹æ³•methods)ï¼›
- å®šä¹‰[åˆå§‹åŒ–å™¨ï¼ˆInitializersï¼‰](#åˆå§‹åŒ–initializations)ï¼›
- å®šä¹‰[ä¸‹æ ‡æ–¹æ³•ï¼ˆSubscript Methodsï¼‰](#ä¸‹æ ‡æ–¹æ³•subscript)ï¼›
- æ”¯æŒ[æ‰©å±•ï¼ˆExtensionsï¼‰](#æ‰©å±•extension)ï¼›
- æ”¯æŒéƒ¨ç½²[åè®®ï¼ˆProtocolsï¼‰](#åè®®protocol)ï¼›

*ç±»ï¼ˆClassï¼‰*è¿˜æœ‰ä¸€äº›é¢å¤–ç‰¹æ€§ï¼š

- å®šä¹‰[ååˆå§‹åŒ–å™¨ï¼ˆDeinitializersï¼‰](#ååˆå§‹åŒ–deinitializations)ï¼›
- æ”¯æŒ[ç»§æ‰¿ï¼ˆInheritanceï¼‰](#ç»§æ‰¿inheritance)ï¼›
- å®ä¾‹å¯ä»¥åœ¨è¿è¡Œæ—¶è¿›è¡Œç±»å‹åˆ¤æ–­å’Œè§£é‡Šï¼ˆ*Type Casting*ï¼‰ï¼›
- ç±»æ˜¯[å¼•ç”¨ç±»å‹](#å€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹value-types--reference-types)ï¼Œå®ä¾‹å¯ä»¥è¢«å¤šæ¬¡å¼•ç”¨ï¼ˆ*Reference Type*ï¼‰ï¼›

[é€‰æ‹©ç»“æ„è¿˜æ˜¯ç±»ï¼Ÿ](https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes)

```swift
// å®šä¹‰
// - å±æ€§å¯ä»¥è®¾ç½®é»˜è®¤å€¼
struct Resolution {
  var width = 0
  var height = 0
}
class VideoMode {
  var resolution = Resolution()
  var interlaced = false
  var frameRate = 0.0
  var name: String?
}

// åˆ›å»ºå®ä¾‹
let someResolution = Resolution()
let someVideoMode = VideoMode()

// ç»“æ„å…·æœ‰ç”Ÿæˆæ‰€æœ‰æˆå‘˜å±æ€§çš„é»˜è®¤æ„é€ å™¨ï¼Œç±»åˆ™æ²¡æœ‰
let vga = Resolution(width: 640, height: 480)

// è®¿é—®å±æ€§
print(someResolution.width)
print(someVideoMode.resolution.width)
```

# å±æ€§ï¼ˆPropertiesï¼‰

> [ç±»ï¼ˆClassesï¼‰](#ç»“æ„structureså’Œç±»classes)ã€[ç»“æ„ï¼ˆStructuresï¼‰](#ç»“æ„structureså’Œç±»classes)å’Œ[æšä¸¾ï¼ˆEnumerationsï¼‰](#æšä¸¾enumerations)å‡å¯ä»¥å®šä¹‰[å±æ€§ï¼ˆPropertiesï¼‰][properties]ã€‚

- å±æ€§éµå¾ª[è®¿é—®æ§åˆ¶](#è®¿é—®æ§åˆ¶access-control)ï¼›
- æ”¯æŒå˜é‡å±æ€§`var`å’Œå¸¸é‡å±æ€§`let`ï¼›
- é€šè¿‡`static`å‰ç¼€å…³é”®å­—å®šä¹‰ç±»å‹å±æ€§ï¼ˆ*Type Properties*ï¼‰ï¼›
- é€šè¿‡`lazy`å‰ç¼€å…³é”®å­—å®šä¹‰æ‡’åŠ è½½å±æ€§ï¼ˆ*Lazy Properties*ï¼‰ï¼›
- æ”¯æŒå®šä¹‰è®¡ç®—å±æ€§ï¼ˆ*Computed Properties*ï¼‰ï¼›
- æ”¯æŒå®šä¹‰å±æ€§è§‚å¯Ÿå™¨ï¼ˆ*Property Observers*ï¼‰ï¼›
- æ”¯æŒå®šä¹‰å±æ€§åŒ…è£…å™¨ï¼ˆ*Property Wrappers*ï¼‰ï¼ˆå³å±æ€§è£…é¥°å™¨ï¼‰ï¼›

## å­˜å‚¨å±æ€§ï¼ˆStored Propertiesï¼‰

> [ç±»ï¼ˆClassesï¼‰](#ç»“æ„structureså’Œç±»classes)æˆ–[ç»“æ„ï¼ˆStructuresï¼‰](#ç»“æ„structureså’Œç±»classes)å¯ä»¥å®šä¹‰[å­˜å‚¨å±æ€§][Stored-Properties]ï¼Œä»¥åœ¨å®ä¾‹ä¸­å­˜å‚¨å˜é‡ï¼ˆ*variable stored property*ï¼‰æˆ–å¸¸é‡ï¼ˆ*constant stored property*ï¼‰ã€‚

```swift
struct FixedLengthRange {
  var firstValue: Int
  let length: Int
}
class DataImporter {
  var filename = "data.txt"
  let mode = "r"
}

// - ç”±äºç»“æ„æ˜¯å€¼ç±»å‹ï¼Œæ•…æƒ³è¦ä¿®æ”¹å±æ€§ï¼Œå®ä¾‹ä¹Ÿå¿…é¡»æ˜¯å¸¸é‡
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
rangeOfThreeItems.firstValue = 6
// ä»¥ä¸‹åˆ™ä¼šæŠ¥é”™ï¼š
let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
rangeOfFourItems.firstValue = 6 // error: cannot assign to property: 'rangeOfFourItems' is a 'let' constant

// - ç±»æ˜¯å¼•ç”¨ç±»å‹ï¼Œæ•…æ²¡æœ‰è¿™ä¸ªé™åˆ¶ï¼š
let dataFile = DataImporter()
dataFile.filename = "data_2.txt"
```

## æ‡’åŠ è½½å±æ€§ï¼ˆ`lazy`ï¼‰

> **æ‡’åŠ è½½å±æ€§ï¼ˆLazy Stored Propertyï¼‰**ç›´åˆ°ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶æ‰è®¡ç®—åˆå§‹å€¼ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœæ‡’åŠ è½½å±æ€§è¢«å¤šä¸ªçº¿ç¨‹è®¿é—®ï¼Œä¸èƒ½ä¿è¯å…¶åªä¼šè¢«åˆå§‹åŒ–ä¸€æ¬¡ã€‚

```swift
class DataManager {
  lazy var importer = DataImporter()
  var data: [String] = []
}
let manager = DataManager()
print(manager.importer.filename) // æ­¤æ—¶importeræ‰è¢«åˆå§‹åŒ–
```

## è®¡ç®—å±æ€§ï¼ˆComputed Propertiesï¼‰

> [ç±»ï¼ˆClassesï¼‰](#ç»“æ„structureså’Œç±»classes)ã€[ç»“æ„ï¼ˆStructuresï¼‰](#ç»“æ„structureså’Œç±»classes)å’Œ[æšä¸¾ï¼ˆEnumerationsï¼‰](#æšä¸¾enumerations)å‡å¯ä»¥å®šä¹‰[è®¡ç®—å±æ€§][Computed-Properties]ï¼Œæä¾›`getter`å’Œ`setter`æ–¹æ³•ã€‚

```swift
struct EEE {
  var text = "e"
  var length: Int {
    get { return text.count }
    set(n) { text = String(repeating: "e", count: n) }
  }
}
```

ç¼–è¯‘å™¨ä¸ä¼šå¯¹è®¡ç®—å±æ€§çš„å‡½æ•°ä½“è‡ªåŠ¨æ¨æ–­ï¼Œå³ä½¿å®ƒæ˜æ˜¾æ˜¯ä¸ªå¸¸é‡ï¼Œæ•…ï¼š
- å¿…é¡»å£°æ˜è®¡ç®—å±æ€§ä¸ºå˜é‡ï¼ˆ`var`ï¼‰
- å¿…é¡»å£°æ˜è®¡ç®—å±æ€§ç±»å‹

```swift
struct EEE {
  <#statements#>
  var target: Character { "e" }
}
```

> **Getterç®€å†™ï¼ˆShorthand Getter Declarationï¼‰**ï¼šåŒå‡½æ•°ä¸€æ ·ï¼Œå¦‚æœGetteråªæœ‰ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå¯ä»¥çœç•¥`return`

> **Setterç®€å†™ï¼ˆShorthand Setter Declarationï¼‰**ï¼šSetterå‚æ•°é»˜è®¤ä¸º`newValue`

```swift
struct EEE {
  <#statements#>
  var len: Int {
    get { text.count }
    set(newValue) { text = String(repeating: "e", count: newValue) }
  }
}
```

> **åªè¯»å±æ€§ï¼ˆRead-Only Computed Propertiesï¼‰**ï¼šå¦‚æœåªæœ‰Getterï¼Œå¯ä»¥ç®€å†™å¦‚ä¸‹

```swift
struct EEE {
  <#statements#>
  var count: Int { text.count }
}
```

## å±æ€§è§‚å¯Ÿå™¨ï¼ˆProperty Observersï¼‰

> [å±æ€§è§‚å¯Ÿå™¨][Property-Observers]ç›‘è§†å¹¶å“åº”å±æ€§çš„å˜åŒ–ï¼Œå³ä½¿èµ‹å€¼å‰åæ˜¯åŒä¸€ä¸ªå€¼ã€‚

è§‚å¯Ÿæ–¹æ³•æœ‰`willSet`, `didSet`ï¼Œå¹¶å¯åœ¨ä»¥ä¸‹åœºæ™¯ä¸‹ç›‘è§†å±æ€§ï¼š

- å®šä¹‰å­˜å‚¨å±æ€§
- ç»§æ‰¿å­˜å‚¨å±æ€§
- ç»§æ‰¿è®¡ç®—å±æ€§

```swift
class StepCounter {
  var totalSteps: Int = 0 {
    willSet(newTotalSteps) {
      print("About to set totalSteps to \(newTotalSteps)")
    }
    // - å’ŒSetterä¸€æ ·ï¼Œæ—§å€¼æ—¢å¯ä»¥è‡ªå®šä¹‰å‚æ•°åï¼Œä¹Ÿæœ‰é»˜è®¤çš„å‚æ•°å`oldValue`
    didSet {
      if totalSteps > oldValue  {
        print("Added \(totalSteps - oldValue) steps")
      }
    }
  }
}
```

ç”±äº`inout`å‚æ•°çš„*copy-In copy-out*æœºåˆ¶ï¼Œè‹¥å°†å±æ€§ä¼ ç»™`inout`å‚æ•°ï¼Œ`willSet`å’Œ`didSet`ä¼šåœ¨å‡½æ•°è°ƒç”¨åæ‰§è¡Œä¸€éï¼š

```swift
func count(_ step: inout Int) {
  step += 1
}
var counter = StepCounter()
count(&counter.totalSteps)
// About to set totalSteps to 1
// Added 1 steps
```

## å±æ€§åŒ…è£…å™¨ï¼ˆ`@propertyWrapper`ï¼‰

> [å±æ€§åŒ…è£…å™¨][Property-Wrappers]çš„ä½œç”¨ç±»ä¼¼æŸäº›ç¼–ç¨‹è¯­è¨€ä¸­çš„è£…é¥°å™¨ï¼Œä½†ä¸“é—¨é’ˆå¯¹äºå±æ€§ã€‚

å®šä¹‰å±æ€§åŒ…è£…å™¨ï¼š

- æ ¹æ®éœ€è¦å®šä¹‰ä¸€ä¸ª[ç»“æ„](#ç»“æ„structureså’Œç±»classes)ã€[ç±»](#ç»“æ„structureså’Œç±»classes)æˆ–[æšä¸¾](#æšä¸¾enumerations)å±æ€§åŒ…è£…å™¨ï¼Œä»¥`@propertyWrapper`ä¿®é¥°ï¼›
- å®šä¹‰ä¸€ä¸ªåä¸º`wrappedValue`çš„è®¡ç®—å±æ€§ä»£ç†å°†è¢«ä¿®é¥°çš„å±æ€§ï¼›

```swift
// ä¸€ä¸ªé™åˆ¶Intå€¼ä¸å¤§äº12çš„ç»“æ„å±æ€§åŒ…è£…å™¨
@propertyWrapper
struct TwelveOrLess {
  private var number = 0
  var wrappedValue: Int {
    get { number }
    set { number = min(newValue, 12) }
  }
}
```

é€šè¿‡åœ¨å±æ€§å‰é¢åŠ ä¸Š`@<#propertyWrapperName#>`è¯­æ³•åº”ç”¨å±æ€§åŒ…è£…å™¨ï¼š

```swift
struct SmallRectangle {
  @TwelveOrLess var height: Int
  @TwelveOrLess var width: Int
}

var rectangle = SmallRectangle()
print(rectangle.height)
// Prints "0"

rectangle.height = 10
print(rectangle.height)
// Prints "10"

rectangle.height = 24
print(rectangle.height)
// Prints "12"
```

å±æ€§åŒ…è£…å™¨æœ¬èº«æ˜¯æŸä¸ªç»“æ„æ•°æ®ï¼ˆç»“æ„ã€ç±»ã€æšä¸¾ç­‰ï¼‰ï¼Œåªæ˜¯å…·æœ‰ç‰¹æ®Šçš„è¯­æ³•çº¦å®šï¼Œæ•…ä¹Ÿå¯ä»¥å½“ä½œæ™®é€šç±»å‹ä½¿ç”¨ï¼š

```swift
struct SmallRectangle {
  private var _height = TwelveOrLess()
  private var _width = TwelveOrLess()
  var height: Int {
    get { return _height.wrappedValue }
    set { _height.wrappedValue = newValue }
  }
  var width: Int {
    get { return _width.wrappedValue }
    set { _width.wrappedValue = newValue }
  }
}
```

### è®¾ç½®è¢«åŒ…è£…å±æ€§çš„åˆå§‹å€¼ï¼ˆSetting Initial Values for Wrapped Propertiesï¼‰

> é€šè¿‡å®šä¹‰å±æ€§åŒ…è£…å™¨çš„åˆå§‹åŒ–å‡½æ•°å¯ä»¥ä¸ºä¸åŒçš„è¢«åŒ…è£…å±æ€§è®¾ç½®åˆå§‹åŒ–å€¼ã€‚

```swift
@propertyWrapper
struct SmallNumber {
  private var maximum: Int
  private var number: Int
  var wrappedValue: Int {
    get { return number }
    set { number = min(newValue, maximum) }
  }
  init() {
    maximum = 12
    number = 0
  }
  init(wrappedValue: Int) {
    maximum = 12
    number = min(wrappedValue, maximum)
  }
  init(wrappedValue: Int, maximum: Int) {
    self.maximum = maximum
    number = min(wrappedValue, maximum)
  }
}
struct SomeNumbers {
  // åº”ç”¨ init() åˆå§‹åŒ–å™¨
  @SmallNumber var a: Int
  // åº”ç”¨ init(wrappedValue:) åˆå§‹åŒ–å™¨
  @SmallNumber var b: Int = 1
  @SmallNumber(wrappedValue: 1) var c: Int
  // åº”ç”¨ init(wrappedValue:maximum:) åˆå§‹åŒ–å™¨
  @SmallNumber(maximum: 2) var d: Int = 3
  @SmallNumber(wrappedValue: 3, maximum: 2) var e: Int
}
var n = SomeNumbers()
assert(n.a == 0)
assert(n.b == 1)
assert(n.c == 1)
assert(n.d == 2)
assert(n.e == 2)
```

# æ–¹æ³•ï¼ˆMethodsï¼‰

> [ç±»ï¼ˆClassesï¼‰](#ç»“æ„structureså’Œç±»classes)ã€[ç»“æ„ï¼ˆStructuresï¼‰](#ç»“æ„structureså’Œç±»classes)å’Œ[æšä¸¾ï¼ˆEnumerationsï¼‰](#æšä¸¾enumerations)å‡å¯ä»¥å®šä¹‰[æ–¹æ³•](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/methods)ï¼ŒåŒ…æ‹¬*å®ä¾‹æ–¹æ³•ï¼ˆinstance methodsï¼‰*å’Œ*ç±»å‹æ–¹æ³•ï¼ˆtype methodsï¼‰*ã€‚

- æ–¹æ³•å°±æ˜¯å…³è”åˆ°æŸä¸ªç±»å‹çš„å‡½æ•°ï¼ˆ*Associated Functions*ï¼‰ï¼Œæ•…æ–¹æ³•å’Œå‡½æ•°å†™æ³•å®Œå…¨ä¸€è‡´ï¼ŒåŒ…æ‹¬ä¸å®šå‚æ•°ã€å‚æ•°æ ‡ç­¾ã€é»˜è®¤å€¼ç­‰ç­‰;
- é€šè¿‡`static`å‰ç¼€å…³é”®å­—å£°æ˜ç±»å‹æ–¹æ³•ï¼ˆ*Type Methods*ï¼‰ï¼›
- æ–¹æ³•æ”¯æŒé‡è½½ï¼ˆ*Overloading*ï¼‰ï¼›
- æ–¹æ³•å†…éƒ¨é€šè¿‡`self`æŒ‡ä»£å½“å‰å®ä¾‹ï¼ˆæˆ–ç±»å‹ï¼‰ï¼›
- æ–¹æ³•å†…éƒ¨å¯ä»¥ï¼ˆä¸é€šè¿‡`self.`ï¼‰ç›´æ¥è°ƒç”¨å®ä¾‹ï¼ˆæˆ–ç±»å‹ï¼‰å±æ€§å’Œå®ä¾‹ï¼ˆæˆ–ç±»å‹ï¼‰æ–¹æ³•ï¼›

```swift
class Counter {
    var count = 0
    func increment() {
        count += 1
    }
    // é‡è½½
    func increment(by amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}
```

ç±»å‹æ–¹æ³•ï¼š

```swift
struct LevelTracker {
    static var highestUnlockedLevel = 1
    var currentLevel = 1

    static func unlock(_ level: Int) {
        if level > highestUnlockedLevel { highestUnlockedLevel = level }
    }

    static func isUnlocked(_ level: Int) -> Bool {
        return level <= highestUnlockedLevel
    }

    @discardableResult
    mutating func advance(to level: Int) -> Bool {
        if LevelTracker.isUnlocked(level) {
            currentLevel = level
            return true
        } else {
            return false
        }
    }
}
```

> [ç±»ï¼ˆClassesï¼‰](#ç»“æ„structureså’Œç±»classes)å¯ä»¥ç”¨`class`å…³é”®å­—ä»£æ›¿`static`ã€‚

```swift
class SomeClass {
    class func someTypeMethod() {
        // type method implementation goes here
    }
}
```

## é€šè¿‡æ–¹æ³•ä¿®æ”¹å€¼ç±»å‹å®ä¾‹ï¼ˆ`mutating`ï¼‰

> å› ä¸º[ç»“æ„ï¼ˆStructuresï¼‰](#ç»“æ„structureså’Œç±»classes)å’Œ[æšä¸¾ï¼ˆEnumerationsï¼‰](#æšä¸¾enumerations)æ˜¯å€¼ç±»å‹ï¼Œæ‰€ä»¥å®ä¾‹åŠå…¶å±æ€§åœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯ä¸èƒ½é€šè¿‡æ™®é€šæ–¹æ³•ä¿®æ”¹çš„ï¼Œéœ€è¦åœ¨æ–¹æ³•å‰æ˜¾å¼åœ°å¢åŠ `mutating`å…³é”®å­—å£°æ˜ã€‚

```swift
struct Point {
    var x = 0.0, y = 0.0
    // ä¿®æ”¹å®ä¾‹å±æ€§
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
    // ç”šè‡³å¯ä»¥ä¿®æ”¹å®ä¾‹æœ¬èº«
    mutating func replaceBy(x: Double, y: Double) {
        self = Point(x: x, y: y)
    }
}
// å³ä½¿å£°æ˜äº†`mutating`ï¼Œè¦æƒ³ä¿®æ”¹ä»éœ€è¦å£°æ˜ä¸ºå˜é‡æ‰å¯ä»¥ï¼š
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
```

## ä¸‹æ ‡æ–¹æ³•ï¼ˆ`subscript`ï¼‰

> [ç±»ï¼ˆClassesï¼‰](#ç»“æ„structureså’Œç±»classes)ã€[ç»“æ„ï¼ˆStructuresï¼‰](#ç»“æ„structureså’Œç±»classes)å’Œ[æšä¸¾ï¼ˆEnumerationsï¼‰](#æšä¸¾enumerations)å‡å¯ä»¥å®šä¹‰[ä¸‹æ ‡æ–¹æ³•](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/subscripts/)ï¼Œç”¨äºå¿«é€Ÿè®¿é—®åºåˆ—ç±»å‹æ•°æ®å…ƒç´ ã€‚

- é€šè¿‡`subscript`å…³é”®å­—å®šä¹‰ä¸‹æ ‡æ–¹æ³•ï¼›
- ä¸‹æ ‡æ–¹æ³•æ”¯æŒé‡è½½ï¼ˆ*Overloading*ï¼‰;
- é™¤äº†æ— æ³•å®šä¹‰~~in-out~~å‚æ•°ï¼Œä¸‹æ ‡æ–¹æ³•å’Œæ™®é€šå‡½æ•°ä¸€æ ·ï¼›
- é€šè¿‡`static`å…³é”®å­—å®šä¹‰ç±»å‹ä¸‹æ ‡æ–¹æ³•ï¼ˆ*Type Subscripts*ï¼‰ï¼›

```swift
subscript(index: Int) -> Int {
    get {
        // Return an appropriate subscript value here.
    }
    set(newValue) {
        // Perform a suitable setting action here.
    }
}
```

åªæœ‰`getter`çš„ä¸‹æ ‡æ–¹æ³•ï¼š

```swift
subscript(index: Int) -> Int {
    // Return an appropriate subscript value here.
}
```

ä¸å®šå‚æ•°ï¼ˆ*Variadic Parameters*ï¼‰å’Œå‚æ•°é»˜è®¤å€¼ï¼ˆ*Default Parameter Values*ï¼‰ï¼š

```swift
struct Matrix {
    let rows: Int, columns: Int
    var grid: [Double]
    init(rows: Int, columns: Int) {
        self.rows = rows
        self.columns = columns
        grid = Array(repeating: 0.0, count: rows * columns)
    }
    func indexIsValid(row: Int, column: Int) -> Bool {
        return row >= 0 && row < rows && column >= 0 && column < columns
    }
    subscript(row: Int, column: Int) -> Double {
        get {
            assert(indexIsValid(row: row, column: column), "Index out of range")
            return grid[(row * columns) + column]
        }
        set {
            assert(indexIsValid(row: row, column: column), "Index out of range")
            grid[(row * columns) + column] = newValue
        }
    }
}
var matrix = Matrix(rows: 2, columns: 2)
matrix[0, 1] = 1.5
```

# åˆå§‹åŒ–ï¼ˆInitializationsï¼‰

## åˆå§‹åŒ–å™¨ï¼ˆ`init`ï¼‰

> [ç±»ï¼ˆClassesï¼‰](#ç»“æ„structureså’Œç±»classes)ã€[ç»“æ„ï¼ˆStructuresï¼‰](#ç»“æ„structureså’Œç±»classes)å’Œ[æšä¸¾ï¼ˆEnumerationsï¼‰](#æšä¸¾enumerations)å‡å¯ä»¥å®šä¹‰[åˆå§‹åŒ–å™¨](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/initialization)ï¼Œç”¨äºåˆå§‹åŒ–[å­˜å‚¨å±æ€§](#å­˜å‚¨å±æ€§stored-properties)ã€‚

- åˆå§‹åŒ–å™¨æ˜¯ä¸€ä¸ªåä¸º`init`çš„[æ–¹æ³•](#æ–¹æ³•methods)ï¼Œä¸è¿”å›å€¼ï¼›
- åˆå§‹åŒ–å™¨æ”¯æŒé‡è½½ï¼ˆ*Overloading*ï¼‰ï¼›
- åˆå§‹åŒ–å™¨ä¸­å¯ä»¥åˆå§‹åŒ–å¸¸é‡`let`å±æ€§ï¼›

```swift
class SurveyQuestion {
    let text: String
    var response: String?
    init(text: String) {
        // åˆå§‹åŒ–å¸¸é‡
        self.text = text
    }
    func ask() {
        print(text)
    }
}
```

## é»˜è®¤åˆå§‹åŒ–å™¨ï¼ˆDefault Initializerï¼‰

> å½“æ‰€æœ‰å­˜å‚¨å±æ€§éƒ½æ— éœ€åˆå§‹åŒ–æ—¶ï¼Œ[ç±»ï¼ˆClassesï¼‰](#ç»“æ„structureså’Œç±»classes)å’Œ[ç»“æ„ï¼ˆStructuresï¼‰](#ç»“æ„structureså’Œç±»classes)å…·æœ‰ä¸€ä¸ª*é»˜è®¤åˆå§‹åŒ–å™¨ï¼ˆDefault Initializerï¼‰*ï¼›

```swift
class ShoppingListItem {
    var name: String?
    var quantity = 1
    var purchased = false
    /* init() {} */
}
var item = ShoppingListItem()
```

> åœ¨å®šä¹‰åˆå§‹åŒ–å™¨åï¼Œé»˜è®¤åˆå§‹åŒ–å™¨å°†å¤±æ•ˆã€‚å¦‚æœ‰å¿…è¦ï¼Œå¯ä»¥å®šä¹‰æ˜¾å¼ä¸€ä¸ªç©ºçš„åˆå§‹åŒ–å™¨ä»£æ›¿ï¼›

```swift
class ShoppingListItem {
    var name: String?
    init() {}
    init(name: String) {
      self.name = name
    }
}
```

> [ç»“æ„ï¼ˆStructuresï¼‰](#ç»“æ„structureså’Œç±»classes)å…·æœ‰ä¸€ä¸ªé»˜è®¤åˆå§‹åŒ–æ‰€æœ‰å­˜å‚¨å±æ€§çš„*æˆå‘˜åˆå§‹åŒ–å™¨ï¼ˆMemberwise Initializerï¼‰*ï¼›

```swift
struct Size {
    var width = 0.0, height = 0.0
}
let twoByTwo = Size(width: 2.0, height: 2.0)
let zeroByTwo = Size(height: 2.0)
let zeroByZero = Size()
```

## åˆå§‹åŒ–å™¨å§”æ‰˜ï¼ˆInitializer Delegationï¼‰

> **åˆå§‹åŒ–å™¨å§”æ‰˜**å¯ä»¥è®©ä½ åœ¨ä¸€ä¸ªåˆå§‹åŒ–å™¨ä¸­è°ƒç”¨å…¶ä»–ï¼ˆåŒ…æ‹¬é‡è½½çš„å’Œç»§æ‰¿çš„ï¼‰åˆå§‹åŒ–å™¨ã€‚

å¯¹äº*å€¼ç±»å‹ï¼ˆValue Typesï¼‰*ï¼ˆç»“æ„å’Œæšä¸¾ï¼‰è€Œè¨€ï¼Œå¯ä»¥ç›´æ¥äº¤å‰è°ƒç”¨åˆå§‹åŒ–å™¨ï¼š

```swift
struct Rect {
    var origin = Point()
    var size = Size()
    init() {}
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
```

å¯¹äº[ç±»](#ç»“æ„structureså’Œç±»classes)è€Œè¨€ï¼Œè¦æƒ³è°ƒç”¨å…¶ä»–å¹³è¡Œçš„åˆå§‹åŒ–å™¨ï¼Œåˆ™å¿…é¡»é€šè¿‡`convenience`å‰ç¼€å…³é”®å­—å£°æ˜**ä¾¿åˆ©åˆå§‹åŒ–å™¨ï¼ˆConvenience Initializersï¼‰**ï¼š

```swift
class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Unnamed]")
    }
}
class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
```

## å¯å¤±è´¥çš„åˆå§‹åŒ–å™¨ï¼ˆ`init?`ï¼‰

> è°ƒç”¨**å¯å¤±è´¥åˆå§‹åŒ–å™¨ï¼ˆFailable Initializerï¼‰**è¿”å›çš„å®ä¾‹æ˜¯å¯ç©ºçš„ï¼ˆ*Optional*ï¼‰çš„ï¼Œå³å¯å¤±è´¥åˆå§‹åŒ–å™¨å¯ä»¥è¿”å›`nil`ã€‚

é€šè¿‡`init?`ï¼ˆæˆ–`init!`ï¼‰å£°æ˜å¯å¤±è´¥åˆå§‹åŒ–å™¨ï¼š

```swift
struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
let someCreature = Animal(species: "Giraffe")
// someCreature is of type Animal?, not Animal

if let giraffe = someCreature {
    print("An animal was initialized with a species of \(giraffe.species)")
}
```

> å¯å¤±è´¥åˆå§‹åŒ–å™¨å¯ä»¥è¢«ï¼ˆå­ç±»ï¼‰æ­£å¸¸åˆå§‹åŒ–å™¨è¦†ç›–ï¼Œåä¹‹åˆ™ä¸è¡Œã€‚

```swift
class Document {
    var name: String?
    // this initializer creates a document with a nil name value
    init() {}
    // this initializer creates a document with a nonempty name value
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
class UntitledDocument: Document {
    override init() {
        super.init(name: "[Untitled]")!
    }
}
```

## å¿…é¡»çš„åˆå§‹åŒ–å™¨ï¼ˆ`required`ï¼‰

> å¯¹äº[ç±»](#ç»“æ„structureså’Œç±»classes)è€Œè¨€ï¼Œå¯ä»¥é€šè¿‡`required`å‰ç¼€å…³é”®å­—å¼ºåˆ¶å­ç±»å¿…é¡»å®ç°è¯¥åˆå§‹åŒ–å™¨ã€‚ï¼ˆå­ç±»çš„è¯¥åˆå§‹åŒ–å™¨å¦‚æœæ˜¯ç»§æ‰¿è€Œæ¥ï¼Œåˆ™æ— éœ€æ˜¾å¼å£°æ˜ã€‚ï¼‰

```swift
class SomeClass {
    required init() {
    }
}
// å­ç±»ä¸­ä¹Ÿå¿…é¡»å£°æ˜ä¸º`required`
class SomeSubclass: SomeClass {
    required init() {
    }
}
```

## é€šè¿‡é—­åŒ…æˆ–å‡½æ•°å£°æ˜å±æ€§é»˜è®¤å€¼

> é—­åŒ…æ‰§è¡Œæ—¶å®ä¾‹è¿˜æœªåˆå§‹åŒ–ï¼Œæ•…é—­åŒ…ä¸­æ— æ³•è°ƒç”¨ä»»ä½•å®ä¾‹å±æ€§æˆ–æ–¹æ³•ã€‚

```swift
class SomeClass {
    let someProperty: SomeType = {
        // create a default value for someProperty inside this closure
        // someValue must be of the same type as SomeType
        return someValue
    }()
}
```

## ååˆå§‹åŒ–ï¼ˆDeinitializationsï¼‰

> [ç±»](#ç»“æ„structureså’Œç±»classes)å¯ä»¥å®šä¹‰ååˆå§‹åŒ–å™¨ã€‚

Swiftæ˜¯è‡ªåŠ¨å†…å­˜ç®¡ç†çš„ï¼Œååˆå§‹åŒ–å™¨åªæ˜¯å®ä¾‹è¢«é”€æ¯å‰ä¸€ä¸ªå¿…å®šä¼šè¢«è‡ªåŠ¨æ‰§è¡Œçš„é’©å­å‡½æ•°ã€‚

```swift
class Bank {
    static var coinsInBank = 10_000
    static func distribute(coins numberOfCoinsRequested: Int) -> Int {
        let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)
        coinsInBank -= numberOfCoinsToVend
        return numberOfCoinsToVend
    }
    static func receive(coins: Int) {
        coinsInBank += coins
    }
}
class Player {
    var coinsInPurse: Int
    init(coins: Int) {
        coinsInPurse = Bank.distribute(coins: coins)
    }
    func win(coins: Int) {
        coinsInPurse += Bank.distribute(coins: coins)
    }
    deinit {
        Bank.receive(coins: coinsInPurse)
    }
}
```

# ç»§æ‰¿ï¼ˆInheritanceï¼‰

> [ç±»ï¼ˆClassesï¼‰](#ç»“æ„structureså’Œç±»classes)æ”¯æŒç»§æ‰¿ã€‚

- å­ç±»å¯ä»¥å‘ç»§æ‰¿çš„æ‰€æœ‰å±æ€§æ·»åŠ [å±æ€§è§‚å¯Ÿå™¨](#å±æ€§è§‚å¯Ÿå™¨property-observers)ï¼›
- å­ç±»å¯ä»¥é€šè¿‡`super`è®¿é—®è¶…ç±»ï¼›
- å­ç±»é€šè¿‡`override`å‰ç¼€å…³é”®å­—è¦†ç›–è¶…ç±»å®šä¹‰çš„å±æ€§æˆ–æ–¹æ³•ï¼›
- é€šè¿‡`final`å‰ç¼€å…³é”®å­—å¯ä»¥é˜²æ­¢å±æ€§æˆ–æ–¹æ³•è¢«è¦†ç›–ï¼›

```swift
class Car: Vehicle {
    // gear æ— æ³•è¢«å­ç±»è¦†ç›–
    final var gear = 1
    // è¦†ç›–å±æ€§ï¼šé€šè¿‡å®šä¹‰setterå’Œgetterå®ç°
    override var description: String {
        return super.description + " in gear \(gear)"
    }
    // è¦†ç›–æ–¹æ³•
    override func makeNoise() {
        print("Choo Choo")
    }
    // å±æ€§è§‚å¯Ÿå™¨
    override var currentSpeed: Double {
        didSet {
            gear = Int(currentSpeed / 10.0) + 1
        }
    }
}
```

# æ‰©å±•ï¼ˆExtensionï¼‰

> é˜”æ‰©å±•æ˜¯ç»™å·²å­˜åœ¨çš„ç»“æ„ã€ç±»ã€æšä¸¾æˆ–åè®®ç­‰æ·»åŠ æ–°çš„åŠŸèƒ½ï¼›

# åè®®ï¼ˆProtocolï¼‰

# æ³›å‹ï¼ˆGenericsï¼‰

# ç‰¹æ€§ï¼ˆAttributesï¼‰

> [ç‰¹æ€§](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/attributes/)å‘*å£°æ˜ï¼ˆDeclarationï¼‰*æˆ–*ç±»å‹ï¼ˆTypeï¼‰*é™„åŠ ä¿¡æ¯ï¼Œç”¨äºæ”¹å˜ç¼–è¯‘å™¨çš„é»˜è®¤è¡Œä¸ºï¼Œç±»ä¼¼*Rust*ä¸­çš„*Attribute Macro*ã€‚

# å¹¶å‘ï¼ˆConcurrencyï¼‰

> SwiftåŸç”Ÿæ”¯æŒå¼‚æ­¥ï¼ˆ*Asynchronous*ï¼‰å’Œå¹¶è¡Œï¼ˆ*Parallel*ï¼‰ï¼Œå¹¶ç»Ÿç§°ä¸º[å¹¶å‘ï¼ˆConcurrencyï¼‰](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency)ã€‚

## å¼‚æ­¥ï¼ˆ`async`ï¼‰

> **å¼‚æ­¥**æ˜¯ä½¿å¼‚æ­¥ä»»åŠ¡åœ¨ä»£ç å±‚é¢å®ç°åŒæ­¥åŒ–è°ƒç”¨çš„ä¸€ç§æ‰‹æ®µã€‚

```swift
func listPhotos(inGallery name: String) async throws -> [String] {
    try await Task.sleep(until: .now + .seconds(2), clock: .continuous)
    return ["IMG001", "IMG99", "IMG0404"]
}
func downloadPhoto(named name: String) async {
  try? await Task.sleep(nanoseconds: 3_000_000_000)
  print("downloaded:" + name)
}
```

å¼‚æ­¥å‡½æ•°å¯è¢«è°ƒç”¨ï¼ˆ`await`ï¼‰çš„ä½ç½®ï¼š

- å¼‚æ­¥ä¸Šä¸‹æ–‡ï¼ˆ`async`ï¼‰å†…éƒ¨ï¼›
- è¢«`@main`æ ‡è®°çš„ç»“æ„ã€ç±»æˆ–æšä¸¾çš„`main()`é™æ€å‡½æ•°å†…éƒ¨ï¼›
- [éç»“æ„åŒ–å¹¶å‘](#éç»“æ„åŒ–å¹¶å‘unstructured-concurrency)ä»»åŠ¡å†…éƒ¨ï¼›

```swift
print(try! await listPhotos(inGallery: "Summer Vacation"))
print(try! await listPhotos(inGallery: "Summer Vacation")[0])
```

> é€šè¿‡`async let`åˆ›å»ºå­ä»»åŠ¡ï¼Œä»¥æ”¯æŒå¼‚æ­¥å‡½æ•°**å¹¶è¡Œè°ƒç”¨**ã€‚

```swift
async let firstPhoto = listPhotos(inGallery: "Summer Vacation")[0]
async let secondPhoto = listPhotos(inGallery: "Summer Vacation")[1]
async let thirdPhoto = listPhotos(inGallery: "Summer Vacation")[2]
let photos = try! await [firstPhoto, secondPhoto, thirdPhoto]
assert(photos == ["IMG001", "IMG99", "IMG0404"])
```

> Swiftçš„å¼‚æ­¥æ˜¯å¤šçº¿ç¨‹è°ƒåº¦ï¼Œæ‰€æœ‰å¼‚æ­¥ä»»åŠ¡éƒ½å¯èƒ½åœ¨ä¸åŒçº¿ç¨‹æ‰§è¡Œï¼Œä»è€Œå¯èƒ½ä¼šäº§ç”Ÿæ•°æ®ç«äº‰é—®é¢˜ã€‚

```swift
var a = 0
func setValue(v: Int) async {
  try? await Task.sleep(nanoseconds: 1_000_000_000)
  // error: main actor-isolated var 'a' can not be mutated from a non-isolated context
  a = v
}
```

ä¸ºäº†è§£å†³å¤šçº¿ç¨‹å¯èƒ½å‡ºç°çš„æ•°æ®ç«äº‰é—®é¢˜ï¼ŒSwiftå¼•å…¥äº†ä¸€ä¸ªå¼‚æ­¥ä¸Šä¸‹æ–‡ï¼š[è¡Œä¸ºä½“ï¼ˆActorsï¼‰](#è¡Œä¸ºä½“actor)ã€‚

### å¼‚æ­¥åºåˆ—ï¼ˆ`AsyncSequence`ï¼‰

> å¼‚æ­¥åºåˆ—å®ç°äº†`AsyncSequence`åè®®ã€‚é€šè¿‡`for-await-in`å¯ä»¥éå†å¼‚æ­¥åºåˆ—ã€‚

```swift
import Foundation

let handle = FileHandle.standardInput
for try await line in handle.bytes.lines {
    print(line)
}
```

## ä»»åŠ¡ï¼ˆTaskï¼‰

> [ä»»åŠ¡ï¼ˆTaskï¼‰](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency#Tasks-and-Task-Groups)ï¼šæ˜¯ç¨‹åºä¸­çš„å¼‚æ­¥æ‰§è¡Œå•å…ƒã€‚æ‰€æœ‰çš„å¼‚æ­¥ä»£ç éƒ½æ˜¯åœ¨ä»»åŠ¡ä¸­çœŸæ­£å®ç°è°ƒç”¨çš„ã€‚

### ç»“æ„åŒ–å¹¶å‘ï¼ˆStructured Concurrencyï¼‰

**ä»»åŠ¡ç»„ï¼ˆTask Groupï¼‰**ç”±æ ¹ä»»åŠ¡å’Œåä»£ä»»åŠ¡ç»„æˆçš„å…·æœ‰å±‚çº§ç»“æ„çš„ä»»åŠ¡é›†åˆã€‚

> é€šè¿‡ä»»åŠ¡ç»„çš„æ–¹å¼éƒ¨ç½²çš„å¹¶å‘ç§°ä¸º**ç»“æ„åŒ–å¹¶å‘ï¼ˆStructured Concurrencyï¼‰**ã€‚

ç»“æ„åŒ–å¹¶å‘ï¼ˆæˆ–è€…è¯´å±‚çº§ç»“æ„ï¼‰çš„ç‰¹ç‚¹ï¼š

- å­ä»»åŠ¡ç”Ÿå‘½å‘¨æœŸä¸ä¼šè¶…è¿‡çˆ¶ä»»åŠ¡ï¼›
- å–æ¶ˆæŸä¸ªä»»åŠ¡ï¼Œå…¶åä»£ä»»åŠ¡å‡ä¼šè¢«å–æ¶ˆï¼›
- é”™è¯¯å¯ä»¥è‡ªåŠ¨å†’æ³¡åˆ°çˆ¶ä»»åŠ¡ï¼›
- å­ä»»åŠ¡é»˜è®¤ç»§æ‰¿çˆ¶ä»»åŠ¡çš„ä¼˜å…ˆçº§ï¼›
- æ‹¥æœ‰æœ¬åœ°æ•°æ®ï¼›

> é€šè¿‡`async let`åˆ›å»º**å¹¶å‘å­ä»»åŠ¡**

- å­ä»»åŠ¡åœ¨åˆ›å»ºåç«‹åˆ»æ‰§è¡Œï¼›

```swift
async let firstPhoto = downloadPhoto(named: "IMG001")
async let secondPhoto = downloadPhoto(named: "IMG002")
async let thirdPhoto = downloadPhoto(named: "IMG003")
try! await [firstPhoto, secondPhoto, thirdPhoto]
// downloaded:IMG001
// downloaded:IMG0404
// downloaded:IMG99
```

> é€šè¿‡`withTaskGroup()`å’Œ`withThrowingTaskGroup()`æ˜¾å¼åˆ›å»º*ä»»åŠ¡ç»„*

```swift
await withTaskGroup(of: Void.self, returning: Void.self) { groupTask in
  let photoNames = ["IMG001", "IMG99", "IMG0404"]

  for name in photoNames {
    // `addTask`æ·»åŠ å­ä»»åŠ¡
    groupTask.addTask { await downloadPhoto(named: name) }
  }
}
// downloaded:IMG001
// downloaded:IMG0404
// downloaded:IMG99
```

### éç»“æ„åŒ–å¹¶å‘ï¼ˆUnstructured Concurrencyï¼‰

> ï¼ˆæ²¡æœ‰çˆ¶ä»»åŠ¡çš„ï¼‰ç‹¬ç«‹ä»»åŠ¡å®ç°çš„å¹¶å‘ç§°ä¸º**éç»“æ„åŒ–å¹¶å‘ï¼ˆUnstructured Concurrencyï¼‰**ã€‚

- é€šè¿‡`Task.init(priority:operation:)`åˆ›å»ºåœ¨å½“å‰ä¸Šä¸‹æ–‡æ‰§è¡Œçš„ä»»åŠ¡ã€‚
- é€šè¿‡`Task.detached(priority:operation:)`åˆ›å»ºéš”ç¦»äºå½“å‰ä¸Šä¸‹æ–‡çš„ä»»åŠ¡ï¼ˆä¸ç»§æ‰¿å½“å‰ä¸Šä¸‹æ–‡çš„ä¼˜å…ˆçº§ã€æ•°æ®ç­‰ï¼‰ã€‚

```swift
// parentTaskæ˜¯éç»“æ„åŒ–ä»»åŠ¡
let parentTask = Task {
  async let test: () = downloadPhoto(named: "IMG001")
  await test
}
await parentTask.value
// downloaded:IMG001
```

### å–æ¶ˆä»»åŠ¡ï¼ˆTask Cancellationï¼‰

ä»»åŠ¡å¯ä»¥é€šè¿‡ä»¥ä¸‹ä¸‰ç§æ–¹å¼å–æ¶ˆï¼š

- æŠ›å‡º`CancellationError`é”™è¯¯ï¼›
- è¿”å›`nil`æˆ–ç©ºé›†åˆï¼›
- è¿”å›éƒ¨åˆ†å®Œæˆçš„ä»»åŠ¡ï¼›

```swift
func noAwaitAsynclet() async {
  print("begin noAwaitAsynclet")
  try? await Task.sleep(nanoseconds: 10_000_000_000)
  Task.isCancelled ? print("noAwaitAsynclet is cancelled") : print("end noAwaitAsynclet")
}

func testAsynclet() async {
  let parentTask = Task {
    async let test: () = noAwaitAsynclet()
    await test
  }
  parentTask.cancel() // å–æ¶ˆä»»åŠ¡ï¼Œsleepä¹Ÿè·Ÿç€å–æ¶ˆäº†
  await parentTask.value
  print("parentTask finished!")
}

await testAsynclet()
// begin noAwaitAsynclet
// noAwaitAsynclet is cancelled
// parentTask finished!
```

## è¡Œä¸ºä½“ï¼ˆActorï¼‰

> [è¡Œä¸ºä½“](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency#Actors)é€šè¿‡æ„å»º**ç‹¬ç«‹çš„å¼‚æ­¥ä¸Šä¸‹æ–‡**ï¼Œè®©å¼‚æ­¥ä»»åŠ¡ä¹‹é—´å®ç°å®‰å…¨çš„æ•°æ®å…±äº«ã€‚

å…·ä½“åœ°ï¼Œè¡Œä¸ºä½“é€šè¿‡å°†æ•°æ®ä½œä¸ºå…¶å†…éƒ¨çŠ¶æ€è¿›è¡Œç»´æŠ¤ï¼Œå¹¶é€šè¿‡*æ¶ˆæ¯ç›’ï¼ˆmailboxï¼‰*ï¼ˆä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—ï¼‰å’Œ*ä¸²è¡Œè°ƒåº¦*æ¥é¿å…æ•°æ®ç«äº‰ã€‚æ•…è¡Œä¸ºä½“å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªä»»åŠ¡å¯ä»¥æ”¹å˜å…¶å†…éƒ¨çŠ¶æ€ï¼›
- åœ¨è¡Œä¸ºä½“å¤–éƒ¨è°ƒç”¨è¡Œä¸ºä½“å†…éƒ¨çŠ¶æ€å‡éœ€è¦è¿›å…¥å¼‚æ­¥é˜Ÿåˆ—ç­‰å¾…æ‰§è¡Œï¼ˆ`await`ï¼‰ï¼›
- è¡Œä¸ºä½“å†…éƒ¨çš„è°ƒç”¨æ˜¯æœ‰åœ¨è¡Œä¸ºä½“å†…éƒ¨è°ƒç”¨è¡Œä¸ºä½“å†…éƒ¨çŠ¶æ€å¯ä»¥ç›´æ¥è°ƒç”¨ï¼›

åœ¨è¯­æ³•å½¢å¼ä¸Šï¼Œé™¤äº†ä¸æ”¯æŒç»§æ‰¿ä»¥å¤–ï¼Œè¡Œä¸ºä½“å’Œç±»ç›¸ä¼¼ï¼Œä¸”éƒ½æ˜¯[å¼•ç”¨ç±»å‹](#å€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹value-types--reference-types)ã€‚

ç¤ºä¾‹å‚è€ƒ-[Swift æ–°å¹¶å‘æ¡†æ¶ä¹‹ actor](https://juejin.cn/post/7076738494869012494)
```swift
actor BankAccount {
  // è¡Œä¸ºä½“çŠ¶æ€
  static var timestamp: Int64 = 0
  let accountNumber: Int
  var balance: Double

  enum BankAccountError: Error {
    case insufficientBalance(Double)
    case authorizeFailed
  }
  // é™¤äº†æ— æ³•ç»§æ‰¿ï¼Œè¡Œä¸ºä½“åŒç±»ä¸€æ ·
  init(accountNumber: Int, initialDeposit: Double) {
    self.accountNumber = accountNumber
    self.balance = initialDeposit
  }
  // å¯¹äºè¡Œä¸ºä½“å†…éƒ¨æ–¹æ³•æ¥è¯´ï¼Œåœ¨ä¸²è¡Œæœºåˆ¶çš„ä¿éšœä¸‹ï¼Œå¯ä»¥ç›´æ¥è°ƒç”¨è¡Œä¸ºä½“çŠ¶æ€
  func deposit(amount: Double) {
    assert(amount >= 0)
    balance = balance + amount
  }
  // è¡Œä¸ºä½“å†…éƒ¨å®šä¹‰å¼‚æ­¥æ–¹æ³•ä¹Ÿæ˜¯å¯ä»¥çš„ï¼š
  func withdraw(amount: Double) async throws -> Double {
    guard balance >= amount else {
      throw BankAccountError.insufficientBalance(balance)
    }
    // è°ƒç”¨å¼‚æ­¥æ–¹æ³•æˆ–å±æ€§
    guard await authorize() else {
      throw BankAccountError.authorizeFailed
    }
    balance -= amount
    return balance
  }
  private func authorize() async -> Bool {
    try? await Task.sleep(nanoseconds: 1_000_000_000)
    return true
  }
}
let ba = BankAccount(accountNumber: 10000, initialDeposit: 100)
// å¯¹äºè¡Œä¸ºä½“å¤–éƒ¨çš„è°ƒç”¨æ¥è¯´ï¼Œï¼ˆæ•°æ®æ˜¯éš”ç¦»çš„*isolated*ï¼‰éƒ½ä¼šè¿›å…¥å¼‚æ­¥é˜Ÿåˆ—ç­‰å¾…æ‰§è¡Œï¼Œæ•…æ‰€æœ‰è°ƒç”¨å‡éœ€è¦ç­‰å¾…ï¼ˆawaitï¼‰
await ba.deposit(amount: 100)
// å˜é‡äº¦æ˜¯
print(await ba.balance)
// å¸¸é‡æ˜¯ä¸å¯å˜çš„çŠ¶æ€ï¼Œæ•…ä¸éœ€è¦
print(ba.accountNumber)
// é™æ€å˜é‡ä¹Ÿä¸éœ€è¦
print(ba.timestamp)
```

> æœ‰æ—¶å†…éƒ¨è°ƒç”¨ç¡®å®æ˜¯åŒæ­¥çš„ï¼Œå¤šä½™çš„å¼‚æ­¥æ’é˜Ÿè°ƒç”¨ä¼šæ‹‰ä½æ€§èƒ½ï¼Œä¸ºäº†ä¼˜åŒ–ï¼ŒSwift5.5æä¾›äº†`nonisolated`å…³é”®å­—ï¼ˆæ²¡æœ‰è®¿é—®éš”ç¦»æ•°æ®ï¼‰ç”±å¼€å‘è€…ä¿è¯å®‰å…¨è°ƒç”¨å‘Šè¯‰ç¼–è¯‘å™¨å¯ä»¥è·³è¿‡å¼‚æ­¥é˜Ÿåˆ—ã€‚

```swift
extension BankAccount {
  // åœ¨è¯¥æ–¹æ³•å†…éƒ¨åªå¼•ç”¨äº† let accountNumberï¼Œæ•…ä¸å­˜åœ¨ Data races
  // ä¹Ÿå°±å¯ä»¥ç”¨ nonisolated ä¿®é¥°
  nonisolated func safeAccountNumberDisplayString() -> String {
    let digits = String(accountNumber)
    return String(repeating: "X", count: digits.count - 4) + String(digits.suffix(4))
  }
}
// ç”±äºnonisolatedçš„ä¿®é¥°ï¼Œå¯ä»¥ç›´æ¥è°ƒç”¨
ba.safeAccountNumberDisplayString()
```

# è®¿é—®æ§åˆ¶ï¼ˆAccess Controlï¼‰

[guidedtour]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/guidedtour/
[aboutthelanguagereference]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/aboutthelanguagereference
[Structures-and-Enumerations-Are-Value-Types]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Structures-and-Enumerations-Are-Value-Types
[Classes-Are-Reference-Types]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures#Classes-Are-Reference-Types
[controlflow]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow
[functions]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions
[closures]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures
[Strong-Reference-Cycles-for-Closures]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/#Strong-Reference-Cycles-for-Closures
[enumerations]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations
[classesandstructures]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/classesandstructures
[properties]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties
[Stored-Properties]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties#Stored-Properties

[Computed-Properties]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties#Computed-Properties
[Property-Observers]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties#Property-Observers
[Property-Wrappers]: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/properties#Property-Wrappers
